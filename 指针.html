<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<link rel="Stylesheet" type="text/css" href="style.css">
<title>指针</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<script src="https://cdn.bootcss.com/jquery/3.3.1/jquery.min.js"></script>
</head>
<body>

<h1>目录：</h1>
<div class="toc">
<ul>
<li><a href="#toc_1">常量指针与指针常量</a>
<li><a href="#toc_2">指针数组和数组指针的区别</a>
<li><a href="#toc_3">注意</a>
</ul>
</div>

<p>
根据指针的类型和值可以确定取出来的值。(估计生成的操作码不一样)
</p>

<p>
只要是指针我们都可以把他拿出来。把指针当作是一个箭头。*叫做间接运算符寻址，必须是指针，因为我要寻址。用址找出变量。最后的结果是变量。把这个理解成靶子，箭头指向它，那么靶子就是一个变量。
</p>

<h1 id="toc_1">常量指针与指针常量</h1>
<p>
前常量，中指针(浅尝而止)(const在前面表示的常量指针，中间const表示的是指针是常量)
常量指针：指向常量的指针	const int *a；
指针常量：指针是常量	int * const a；（在指针前面加个常量就行）
</p>


<p>
&amp;取址运算符，必须是左值，因为我要取址。注：地址是指针类型的，所以得到的值就是指针类型的。（得到地址），取地址赋值给指针，要看这个地址是常量的地址还是非常量的地址，如果是常量的地址就不要赋给非常量的指针，免得通过指针把该常量给修改了。常量的地址要特别注意。
</p>

<p>
指针占的空间不管什么类型都是一样大的，跟你的计算机位数相同，要分类型是因为指针指向的是一个空间（目标，一个包）（空间一般用首地址表示，用类型表示大小），其是有大小的，多大就用类型来表示（指针指的不是一个地址，而是一个目标，它能指向多大就要看它的类型）,很多时候指针指向的类型的大小已经没有意义了，没有意义的东西你想它干嘛。
</p>

<p>
空指针指向零地址，但是它没有类型，没有类型就没有目标可指。所以没有大小，不表示空间。只是一个大小（空间是空的）
</p>

<p>
Void * 是一个类型来的，原来的c语言没有空指针，用char *做通用指针，用的时候必须先转换为其他真正类型指针。注意野指针跟类型没有关系，只是跟有没有赋值有关系，只要赋值了就不是野指针了。
</p>


<p>
只有指向同一个数组中元素的指针之间相互比较才有意义，否则没有意义
</p>

<p>
参数不管写成数组形式还是指针形式，对于编译器来说没区别，都是指针，如果指针指向参数，则，写成指针形式，如果指向一串元素的首元素，则用数组形式。使用数组的方式只是为了更形象。(它后面的是同一类型的数据)，函数原型中的[]表示指针，不表示数组。只是数组形式。写成数组形式是因为提示a不是单个指针，而是指向一个指针数组的首元素。也就是说这个指针后面还有一样类型的，他们可以组成数组这样一个信息提供了。总之就是为了说明后面类型一样。可以是数组
</p>


<p>
把不该变的都声明成const指针。
</p>

<h1 id="toc_2">指针数组和数组指针的区别</h1>
<p>
指针数组：是一个<code>数组</code>，数组里面是指针。申明形式：int  *a[]；数组里面的是int型的指针.a[]数组，int * 里面放的是指针。
</p>

<p>
数组指针：是一个<code>指针</code>，int （*a）[5]; 这表示的是定义一个指针，名字叫做a，a是指向有5个元素(数组)的指针。a -&gt; ｜｜｜｜｜｜｜。a是指针的指针，它里面放的是首元素的指针。而它本身代表的是整个数组的指针。首地址就是&amp;a，即数组a的地址，大小看类型，int t[5];
 a就是二维数组地址。
</p>


<p>
指针数组是一个数组，数组里面的是指针。数组指针是一个指针，指针指向一个数组对象。注意指针是指向一个对象的。比如指向整型，指向浮点型，指向数组型，指向数组就是指向整个数组，而不是数组中的某些。
</p>


<p>
int a[5][10];和int (*pa)[10]  a表示首行的指针，它指向首行的十列即10个数。pa是指向有10数的指针。所以等价;之间的关系同样类似于int a[10];和int *pa;之间的关系，a表示首元素的指针，指向的是整型。pa也是指向整型的一个元素。
</p>

<p>
a -&gt;	| | |……
		| | |……
		……
		| | |……
</p>

<p>
其实在真正的内存中是一个挨一个的，这样画形象一点。
</p>

<p>
一个老伯伯指着一个包：<code>从这地址开始有10个都是我的</code>
</p>
<h1 id="toc_3">注意</h1>


<p>
const char **p;char *const *p;char **const p;
</p>

<p>
定义一个指针变量，那么该变量的空间就是4个字节（32位机），用来存地址，而类型的大小是那个地址开始算的大小。
</p>


<p>
NULL是空指针，是一个宏定义，定义为0，经过void *强制转换，该0是指针类型，大小不知道。操作系统不会把任何数据保存到地址0和它的附近。也不会把0~0Xfff的也面映射到物理内存。所以对0地址的访问会立即造成段错误。
</p>

<p>
Void *型指针。为什么不能声明不知道类型的变量，即void变量，而可以声明不知道类型的指针，即void *指针，这是因为不管什么类型的指针，都是地址，它所分配的内存空间是确定的，32位机就是4个字节，而变量的空间是不确定的，编译器不知道分配多少空间给变量。
</p>

<p>
数组的实参只要数组名，形参只需数组名加中括号
</p>

<p>
函数声明的数组参数中，不用指定数组的长度。
</p>

<p>
函数可以接收任何长度的数组，传递参数中必须有单独的参数作为数组的长度。因为[]已经不表示数组了，而是指针了，我可以一直加下去。为了不要一直指下去造成数据的改动，需要一个指下去的长度。
</p>

<p>
数组参数是以引用（传址调用）的形式传递的
</p>

<p>
数组名作右值是自动转换成首元素的指针。
</p>

<p>
a[2] = ｛1，2｝，a是首元素的指针，指针的类型和数组的类型。*a就是首元素，即为1。
</p>

<p>
因为a[2] 等价于*(a + 2)故pa[2]也等价于*（pa + 2）,都是通过指针间接寻址访问元素。故2[a]也是对的。注：2是两个元素。
</p>

<p>
字符串字面值类似于数组名。
</p>


<p>
做右值使用时自动转换成指向首元素的指针，这种指针应该是const char *型
</p>

<p>
数组是以引用的形式进行传递的。
</p>

<p>
数组名是指针常量。不能作为左值。int b[];b是指针常量，它是一个指针，它指向一个空间，如果指向的空间不是常量，那么指向的空间就可以是左值，如*b，可以是左值。但b不能是左值。
</p>

<p>
指针在解操作引用之前要检查它是否有效非常重要。
toc 目录：
</p>

<button class="back_to_top" style='background-color:red'>返回顶部</button>

<a href="https://weipiaoyun.github.io/note_html/">
<button class="back_to_index" style='background-color:red'>返回首页</button>
</a>

<script src="my.js"></script>
<HR SIZE=5>
<p class="left">
<!-- <div class="text" style=" text-align:center;font-size:15px"></div>-->
© <span id="year">2018</span> 
</p>
</body>
</body>
</html>
