<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<link rel="Stylesheet" type="text/css" href="style.css">
<title>正则表达式</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<script src="https://cdn.bootcss.com/jquery/3.3.1/jquery.min.js"></script>
</head>
<body>

<p>
(abc(-gn)?) abc-gn  算出来的结果：\(1 = abc-gn; \)2 = -gn;
</p>

<p>
\s空白字符。\S非空白字符
?是零次或一次，.是匹配除换行符外的任何单个字符(就一个字符，不能是没有或者多个)。+是匹配一个以上,\d匹配一个数字(?.+*)
\w匹配一个字母，数字或下滑线[a-zA-Z_0-9]
.*可以匹配任何东西(个数也不定);
点的匹配\.
[]字符类只表示一个字符。里面是或的关系。在字符类里*表示的就是*，其失去了通配符的性质。而<sup><small>这个表示字符类的非。在字符类里面\],\</small></sup>,\-三个为非普通字符。
</p>

<p>
使用\Q会使得正则除字母，数字，下划线的字符之前自动加上反斜杠\,用-E作结束。
</p>

<p>
匹配一个单词，而不是具有字符串的单词用\bstring\b
(d)(\w+),一个d，然后一个以上的字符，只要是字符，数字或下滑线，可以不一样的。
\w字符数字或下滑线
^在中括号内表示非
[^0-9]表示的是非0-9。注意[]必须占一个字符，如果允许0个字符，加{0}或*
\d = [0-9]
\D表示非数字
当只有一个字符的时候[0123]等于0|1|2|3。当多个的时候用ab|cd|ef
(\(1)(\)2)
</p>

<p>
正则表达式的三种形式：匹配，替换，转换
八大原则：1，三种形式。2，标量匹配。3，缺省值：匹配最先找到的，只匹配一次。4，和双引号一样，正则里面能解析变量
.是通配符而*是多重匹配
</p>

<p>
(ab\d){1,}多重匹配括号内所有
</p>

<h2 id="toc_0.1">多重匹配</h2>
<p>
?0次或1次。(修饰，多元匹配)，非贪婪模式匹配
+一个以上(修饰，多元匹配)
*匹配表多个，1*表示任何多个前面的1，.*,表示任何多个前面的.
{m,n}标识m个到n个
</p>

<p>
.代表任意单个字符(就一个字符，不能多个或没有)(除换行符外)
使用非贪婪模式更好处理问题。非贪婪模式表示，只要符合条件，就可以了，不会去贪婪。
</p>

<h2 id="toc_0.2">关系运算符</h2>
<h1 id="toc_1">|的优先级很低</h1>
<p>
gto|gts|gtl|sec.*t|in.*t   #表示的是gto或gts或gtl，而不是gto或gtg
</p>


<p>
^gt[lso](1|_[wp])?$
</p>

<p>
abc|efg表示的是abc或者efg。|的优先级比较低。
</p>

<h2 id="toc_1.1">常用正则</h2>
<p>
获取最后一个括号里面的内容：.<strong>\((.+)\).</strong>\(   获取\)1
</p>


<p>
常用正则表达式大全！（例如：匹配中文、匹配html）
</p>

<p>
 匹配中文字符的正则表达式： [u4e00-u9fa5]   
　　评注：匹配中文还真是个头疼的事，有了这个表达式就好办了 
　　匹配双字节字符(包括汉字在内)：[^x00-xff] 
　　评注：可以用来计算字符串的长度（一个双字节字符长度计2，ASCII字符计1） 
　　匹配空白行的正则表达式：ns*r 
　　评注：可以用来删除空白行 
　　匹配HTML标记的正则表达式：&lt;(S*?)[^&gt;]<strong>&gt;.</strong>?|&lt;.*? /&gt; 
　　评注：网上流传的版本太糟糕，上面这个也仅仅能匹配部分，对于复杂的嵌套标记依旧无能为力 
　　匹配首尾空白字符的正则表达式：^s*|s*$ 
　　评注：可以用来删除行首行尾的空白字符(包括空格、制表符、换页符等等)，非常有用的表达式 
　　匹配Email地址的正则表达式：w+([-+.]w+)<strong>@w+([-.]w+)</strong>.w+([-.]w+)* 
　　评注：表单验证时很实用 
　　匹配网址URL的正则表达式：[a-zA-z]+://[^s]* 
　　评注：网上流传的版本功能很有限，上面这个基本可以满足需求 
　　匹配帐号是否合法(字母开头，允许5-16字节，允许字母数字下划线)：^[a-zA-Z][a-zA-Z0-9_]{4,15}$ 
　　评注：表单验证时很实用 
　　匹配国内电话号码：d{3}-d{8}|d{4}-d{7} 
　　评注：匹配形式如 0511-4405222 或 021-87888822 
　　匹配腾讯QQ号：[1-9][0-9]{4,} 
　　评注：腾讯QQ号从10000开始 
　　匹配中国邮政编码：[1-9]d{5}(?!d) 
　　评注：中国邮政编码为6位数字 
　　匹配身份证：d{15}|d{18} 
　　评注：中国的身份证为15位或18位 
　　匹配ip地址：d+.d+.d+.d+ 
　　评注：提取ip地址时有用 
　　匹配特定数字： 
　　^[1-9]\d*$　 　 //匹配正整数 
　　^-[1-9]\d*$ 　 //匹配负整数 
　　^-?[1-9]\d*$　　 //匹配整数 
　　^[1-9]\d*|0$　 //匹配非负整数（正整数 + 0） 
　　^-[1-9]d*|0$　　 //匹配非正整数（负整数 + 0） 
　　^[1-9]d*.d*|0.d*[1-9]d*$　　 //匹配正浮点数 
　　^-([1-9]d*.d*|0.d*[1-9]d*)$　 //匹配负浮点数 
　　^-?([1-9]d*.d*|0.d*[1-9]d*|0?.0+|0)$　 //匹配浮点数 
　　^[1-9]d*.d*|0.d*[1-9]d*|0?.0+|0$　　 //匹配非负浮点数（正浮点数 + 0） 
　　^(-([1-9]d*.d*|0.d*[1-9]d*))|0?.0+|0$　　//匹配非正浮点数（负浮点数 + 0） 
　　评注：处理大量数据时有用，具体应用时注意修正 
　　匹配特定字符串： 
　　^[A-Za-z]+$　　//匹配由26个英文字母组成的字符串 
　　^[A-Z]+$　　//匹配由26个英文字母的大写组成的字符串 
　　^[a-z]+$　　//匹配由26个英文字母的小写组成的字符串 
　　^[A-Za-z0-9]+$　　//匹配由数字和26个英文字母组成的字符串 
　　^w+$　　//匹配由数字、26个英文字母或者下划线组成的字符串 
　　在使用RegularExpressionValidator验证控件时的验证功能及其验证表达式介绍如下: 
　　只能输入数字：“^[0-9]*$” 
　　只能输入n位的数字：“^d{n}$” 
　　只能输入至少n位数字：“^d{n,}$” 
　　只能输入m-n位的数字：“^d{m,n}$” 
　　只能输入零和非零开头的数字：“^(0|[1-9][0-9]*)$” 
　　只能输入有两位小数的正实数：“^[0-9]+(.[0-9]{2})?$” 
　　只能输入有1-3位小数的正实数：“^[0-9]+(.[0-9]{1,3})?$” 
　　只能输入非零的正整数：“^+?[1-9][0-9]*$” 
　　只能输入非零的负整数：“^-[1-9][0-9]*$” 
　　只能输入长度为3的字符：“^.{3}$” 
　　只能输入由26个英文字母组成的字符串：“^[A-Za-z]+$” 
　　只能输入由26个大写英文字母组成的字符串：“^[A-Z]+$” 
　　只能输入由26个小写英文字母组成的字符串：“^[a-z]+$” 
　　只能输入由数字和26个英文字母组成的字符串：“^[A-Za-z0-9]+$” 
　　只能输入由数字、26个英文字母或者下划线组成的字符串：“^w+$” 
　　验证用户密码:“^[a-zA-Z]w{5,17}$”正确格式为：以字母开头，长度在6-18之间， 
　　只能包含字符、数字和下划线。 
　　验证是否含有^%&amp;'',;=?\("等字符：“[^%&amp;'',;=?\)x22]+” 
　　只能输入汉字：“^[u4e00-u9fa5],{0,}$” 
　　验证Email地址：“^w+[-+.]w+)<strong>@w+([-.]w+)</strong>.w+([-.]w+)*$” 
　　验证InternetURL：“^<a href="http://([w-]+.)+[w-]+(/[w-./?%&amp;=]*)?\(”">http://([w-]+.)+[w-]+(/[w-./?%&amp;=]*)?\)”</a> 
　　验证电话号码：“^((d{3,4})|d{3,4}-)?d{7,8}$” 
　　正确格式为：“XXXX-XXXXXXX”，“XXXX-XXXXXXXX”，“XXX-XXXXXXX”， 
　　“XXX-XXXXXXXX”，“XXXXXXX”，“XXXXXXXX”。 
　　验证身份证号（15位或18位数字）：“^d{15}|d{}18$” 
　　验证一年的12个月：“^(0?[1-9]|1[0-2])$”正确格式为：“01”-“09”和“1”“12” 
　　验证一个月的31天：“^((0?[1-9])|((1|2)[0-9])|30|31)$” 
　　正确格式为：“01”“09”和“1”“31”。 
　　匹配中文字符的正则表达式： [u4e00-u9fa5] 
　　匹配双字节字符(包括汉字在内)：[^x00-xff] 
　　匹配空行的正则表达式：n[s| ]*r 
　　匹配HTML标记的正则表达式：/&lt;(.<strong>)&gt;.</strong>|&lt;(.*) /&gt;/ 
　　匹配首尾空格的正则表达式：(^s*)|(s*$) 
　　匹配Email地址的正则表达式：w+([-+.]w+)<strong>@w+([-.]w+)</strong>.w+([-.]w+)* 
　　匹配网址URL的正则表达式：<a href="http://([w-]+.)+[w-]+(/[w-">http://([w-]+.)+[w-]+(/[w-</a> ./?%&amp;=]*)? 
　　(1)应用：计算字符串的长度（一个双字节字符长度计2，ASCII字符计1） 
　　String.prototype.len=function(){return this.replace([^x00-xff]/g,"aa").length;} 
　　(2)应用：javascript中没有像vbscript那样的trim函数，我们就可以利用这个表达式来实现 
　　String.prototype.trim = function() 
　　{ 
　　return this.replace(/(^s*)|(s*$)/g, ""); 
　　} 
　　(3)应用：利用正则表达式分解和转换IP地址 
　　function IP2V(ip) //IP地址转换成对应数值 
　　{ 
　　re=/(d+).(d+).(d+).(d+)/g //匹配IP地址的正则表达式 
　　if(re.test(ip)) 
　　{ 
　　return RegExp.\(1*Math.pow(255,3))+RegExp.\)2*Math.pow(255,2))+RegExp.\(3*255+RegExp.\)4*1 
　　} 
　　else 
　　{ 
　　throw new Error("Not a valid IP address!") 
　　} 
　　} 
　　(4)应用：从URL地址中提取文件名的javascript程序 
　　s="<a href="http://www.9499.net/page1.htm";">http://www.9499.net/page1.htm";</a> 
　　s=s.replace(/(.<strong>/){0,}([^.]+).</strong>/ig,"$2") ;//Page1.htm 
　　(5)应用：利用正则表达式限制网页表单里的文本框输入内容 
　　用正则表达式限制只能输入中文：onkeyup="value=value.replace(/[<sup><small>u4E00-u9FA5]/g,'') "onbeforepaste="clipboardData.setData(''text'',clipboardData.getData(''text'').replace(/[</small></sup>u4E00-u9FA5]/g,''))" 
　　用正则表达式限制只能输入全角字符： onkeyup="value=value.replace(/[<sup><small>uFF00-uFFFF]/g,'') "onbeforepaste="clipboardData.setData(''text'',clipboardData.getData(''text'').replace(/[</small></sup>uFF00-uFFFF]/g,''))" 
　　用正则表达式限制只能输入数字：onkeyup="value=value.replace(/[<sup><small>d]/g,'') "onbeforepaste= "clipboardData.setData(''text'',clipboardData.getData(''text'').replace(/[</small></sup>d]/g,''))" 
　　用正则表达式限制只能输入数字和英文：onkeyup="value=value.replace(/[W]/g,'') "onbeforepaste="clipboardData.setData(''text'',clipboardData.getData(''text'').replace(/[^d]/g,'' 
</p>

 
<p>
1. 正则表达式规则
1.1 普通字符
</p>
<blockquote>
字母、数字、汉字、下划线、以及后边章节中没有特殊定义的标点符号，都是"普通字符"。表达式中的普通字符，在匹配一个字符串的时候，匹配与之相同的一个字符。
</blockquote>
<blockquote>
举例1：表达式 "c"，在匹配字符串 "abcde" 时，匹配结果是：成功；匹配到的内容是："c"；匹配到的位置是：开始于2，结束于3。（注：下标从0开始还是从1开始，因当前编程语言的不同而可能不同）
</blockquote>
<blockquote>
举例2：表达式 "bcd"，在匹配字符串 "abcde" 时，匹配结果是：成功；匹配到的内容是："bcd"；匹配到的位置是：开始于1，结束于4。
</blockquote>


<hr />

<p>
1.2 简单的转义字符
</p>
<blockquote>
一些不便书写的字符，采用在前面加 "\" 的方法。这些字符其实我们都已经熟知了。
</blockquote>

<p>
表达式
 可匹配
</p>
 
<p>
\r, \n
 代表回车和换行符
</p>
 
<p>
\t
 制表符
</p>
 
<p>
\\
 代表 "\" 本身
</p>
<blockquote>
还有其他一些在后边章节中有特殊用处的标点符号，在前面加 "\" 后，就代表该符号本身。比如：^, \( 都有特殊意义，如果要想匹配字符串中 "^" 和 "\)" 字符，则表达式就需要写成 "\^" 和 "\$"。
</blockquote>

<p>
表达式
 可匹配
</p>
 
<p>
\^
 匹配 ^ 符号本身
</p>
 
<p>
\$
 匹配 $ 符号本身
</p>
 
<p>
\.
 匹配小数点（.）本身
</p>
<blockquote>
这些转义字符的匹配方法与 "普通字符" 是类似的。也是匹配与之相同的一个字符。
</blockquote>
<blockquote>
举例1：表达式 "\\(d"，在匹配字符串 "abc\)de" 时，匹配结果是：成功；匹配到的内容是："$d"；匹配到的位置是：开始于3，结束于5。
</blockquote>


<hr />

<p>
1.3 能够与 '多种字符' 匹配的表达式
</p>
<blockquote>
正则表达式中的一些表示方法，可以匹配 '多种字符' 其中的任意一个字符。比如，表达式 "\d" 可以匹配任意一个数字。虽然可以匹配其中任意字符，但是只能是一个，不是多个。这就好比玩扑克牌时候，大小王可以代替任意一张牌，但是只能代替一张牌。
</blockquote>

<p>
表达式
 可匹配
</p>
 
<p>
\d
 任意一个数字，0~9 中的任意一个
</p>
 
<p>
\w
 任意一个字母或数字或下划线，也就是 A~Z,a~z,0~9,_ 中任意一个
</p>
 
<p>
\s
 包括空格、制表符、换页符等空白字符的其中任意一个
</p>
 
<p>
.
 小数点可以匹配除了换行符（\n）以外的任意一个字符
</p>
<blockquote>
举例1：表达式 "\d\d"，在匹配 "abc123" 时，匹配的结果是：成功；匹配到的内容是："12"；匹配到的位置是：开始于3，结束于5。
</blockquote>
<blockquote>
举例2：表达式 "a.\d"，在匹配 "aaa100" 时，匹配的结果是：成功；匹配到的内容是："aa1"；匹配到的位置是：开始于1，结束于4。
</blockquote>


<hr />

<p>
1.4 自定义能够匹配 '多种字符' 的表达式
</p>
<blockquote>
使用方括号 [ ] 包含一系列字符，能够匹配其中任意一个字符。用 [^ ] 包含一系列字符，则能够匹配其中字符之外的任意一个字符。同样的道理，虽然可以匹配其中任意一个，但是只能是一个，不是多个。
</blockquote>

<p>
表达式
 可匹配
</p>
 
<p>
[ab5@]
 匹配 "a" 或 "b" 或 "5" 或 "@"
</p>
 
<p>
[^abc]
 匹配 "a","b","c" 之外的任意一个字符
</p>
 
<p>
[f-k]
 匹配 "f"~"k" 之间的任意一个字母
</p>
 
<p>
[^A-F0-3]
 匹配 "A"~"F","0"~"3" 之外的任意一个字符
</p>
<blockquote>
举例1：表达式 "[bcd][bcd]" 匹配 "abc123" 时，匹配的结果是：成功；匹配到的内容是："bc"；匹配到的位置是：开始于1，结束于3。
</blockquote>
<blockquote>
举例2：表达式 "[^abc]" 匹配 "abc123" 时，匹配的结果是：成功；匹配到的内容是："1"；匹配到的位置是：开始于3，结束于4。
</blockquote>


<hr />

<p>
1.5 修饰匹配次数的特殊符号
</p>
<blockquote>
前面章节中讲到的表达式，无论是只能匹配一种字符的表达式，还是可以匹配多种字符其中任意一个的表达式，都只能匹配一次。如果使用表达式再加上修饰匹配次数的特殊符号，那么不用重复书写表达式就可以重复匹配。
</blockquote>
<blockquote>
使用方法是："次数修饰"放在"被修饰的表达式"后边。比如："[bcd][bcd]" 可以写成 "[bcd]{2}"。
</blockquote>

<p>
表达式
 作用
</p>
 
<p>
{n}
 表达式重复n次，比如："\w{2}" 相当于 "\w\w"；"a{5}" 相当于 "aaaaa"
</p>
 
<p>
{m,n}
 表达式至少重复m次，最多重复n次，比如："ba{1,3}"可以匹配 "ba"或"baa"或"baaa"
</p>
 
<p>
{m,}
 表达式至少重复m次，比如："\w\d{2,}"可以匹配 "a12","_456","M12344"...
</p>
 
<p>
?
 匹配表达式0次或者1次，相当于 {0,1}，比如："a[cd]?"可以匹配 "a","ac","ad"
</p>
 
<p>
+
 表达式至少出现1次，相当于 {1,}，比如："a+b"可以匹配 "ab","aab","aaab"...
</p>
 
<p>
*
 表达式不出现或出现任意次，相当于 {0,}，比如："\<sup><small>*b"可以匹配 "b","</small></sup>^^b"...
</p>
<blockquote>
举例1：表达式 "\d+\.?\d*" 在匹配 "It costs $12.5" 时，匹配的结果是：成功；匹配到的内容是："12.5"；匹配到的位置是：开始于10，结束于14。
</blockquote>
<blockquote>
举例2：表达式 "go{2,8}gle" 在匹配 "Ads by goooooogle" 时，匹配的结果是：成功；匹配到的内容是："goooooogle"；匹配到的位置是：开始于7，结束于17。
</blockquote>


<hr />

<p>
1.6 其他一些代表抽象意义的特殊符号
</p>
<blockquote>
一些符号在表达式中代表抽象的特殊意义：
</blockquote>

<p>
表达式
 作用
</p>
 
<p>
^
 与字符串开始的地方匹配，不匹配任何字符
</p>
 
<p>
$
 与字符串结束的地方匹配，不匹配任何字符
</p>
 
<p>
\b
 匹配一个单词边界，也就是单词和空格之间的位置，不匹配任何字符
</p>
<blockquote>
进一步的文字说明仍然比较抽象，因此，举例帮助大家理解。
</blockquote>
<blockquote>
举例1：表达式 "<sup><small>aaa" 在匹配 "xxx aaa xxx" 时，匹配结果是：失败。因为 "</small></sup>" 要求与字符串开始的地方匹配，因此，只有当 "aaa" 位于字符串的开头的时候，"^aaa" 才能匹配，比如："aaa xxx xxx"。
</blockquote>
<blockquote>
举例2：表达式 "aaa\(" 在匹配 "xxx aaa xxx" 时，匹配结果是：失败。因为 "\)" 要求与字符串结束的地方匹配，因此，只有当 "aaa" 位于字符串的结尾的时候，"aaa$" 才能匹配，比如："xxx xxx aaa"。
</blockquote>
<blockquote>
举例3：表达式 ".\b." 在匹配 "@@@abc" 时，匹配结果是：成功；匹配到的内容是："@a"；匹配到的位置是：开始于2，结束于4。
进一步说明："\b" 与 "^" 和 "$" 类似，本身不匹配任何字符，但是它要求它在匹配结果中所处位置的左右两边，其中一边是 "\w" 范围，另一边是 非"\w" 的范围。
</blockquote>
<blockquote>
举例4：表达式 "\bend\b" 在匹配 "weekend,endfor,end" 时，匹配结果是：成功；匹配到的内容是："end"；匹配到的位置是：开始于15，结束于18。
</blockquote>
<blockquote>
一些符号可以影响表达式内部的子表达式之间的关系：
</blockquote>

<p>
表达式
 作用
</p>
 
<p>
|
 左右两边表达式之间 "或" 关系，匹配左边或者右边
</p>
 
<p>
( )
 (1). 在被修饰匹配次数的时候，括号中的表达式可以作为整体被修饰
(2). 取匹配结果的时候，括号中的表达式匹配到的内容可以被单独得到
</p>
<blockquote>
举例5：表达式 "Tom|Jack" 在匹配字符串 "I'm Tom, he is Jack" 时，匹配结果是：成功；匹配到的内容是："Tom"；匹配到的位置是：开始于4，结束于7。匹配下一个时，匹配结果是：成功；匹配到的内容是："Jack"；匹配到的位置时：开始于15，结束于19。
</blockquote>
<blockquote>
举例6：表达式 "(go\s*)+" 在匹配 "Let's go go go!" 时，匹配结果是：成功；匹配到内容是："go go go"；匹配到的位置是：开始于6，结束于14。
</blockquote>
<blockquote>
举例7：表达式 "￥(\d+\.?\d*)" 在匹配 "＄10.9,￥20.5" 时，匹配的结果是：成功；匹配到的内容是："￥20.5"；匹配到的位置是：开始于6，结束于10。单独获取括号范围匹配到的内容是："20.5"。
</blockquote>


<hr />

<p>
2. 正则表达式中的一些高级规则
2.1 匹配次数中的贪婪与非贪婪
</p>
<blockquote>
在使用修饰匹配次数的特殊符号时，有几种表示方法可以使同一个表达式能够匹配不同的次数，比如："{m,n}", "{m,}", "?", "*", "+"，具体匹配的次数随被匹配的字符串而定。这种重复匹配不定次数的表达式在匹配过程中，总是尽可能多的匹配。比如，针对文本 "dxxxdxxxd"，举例如下：
</blockquote>

<p>
表达式
 匹配结果
</p>
 
<p>
(d)(\w+)
 "\w+" 将匹配第一个 "d" 之后的所有字符 "xxxdxxxd"
</p>
 
<p>
(d)(\w+)(d)
 "\w+" 将匹配第一个 "d" 和最后一个 "d" 之间的所有字符 "xxxdxxx"。虽然 "\w+" 也能够匹配上最后一个 "d"，但是为了使整个表达式匹配成功，"\w+" 可以 "让出" 它本来能够匹配的最后一个 "d"
</p>
<blockquote>
由此可见，"\w+" 在匹配的时候，总是尽可能多的匹配符合它规则的字符。虽然第二个举例中，它没有匹配最后一个 "d"，但那也是为了让整个表达式能够匹配成功。同理，带 "*" 和 "{m,n}" 的表达式都是尽可能地多匹配，带 "?" 的表达式在可匹配可不匹配的时候，也是尽可能的 "要匹配"。这 种匹配原则就叫作 "贪婪" 模式 。
</blockquote>
<blockquote>
非贪婪模式：
</blockquote>
<blockquote>
在修饰匹配次数的特殊符号后再加上一个 "?" 号，则可以使匹配次数不定的表达式尽可能少的匹配，使可匹配可不匹配的表达式，尽可能的 "不匹配"。这种匹配原则叫作 "非贪婪" 模式，也叫作 "勉强" 模式。如果少匹配就会导致整个表达式匹配失败的时候，与贪婪模式类似，非贪婪模式会最小限度的再匹配一些，以使整个表达式匹配成功。举例如下，针对文本 "dxxxdxxxd" 举例：
</blockquote>

<p>
表达式
 匹配结果
</p>
 
<p>
(d)(\w+?)
 "\w+?" 将尽可能少的匹配第一个 "d" 之后的字符，结果是："\w+?" 只匹配了一个 "x"
</p>
 
<p>
(d)(\w+?)(d)
 为了让整个表达式匹配成功，"\w+?" 不得不匹配 "xxx" 才可以让后边的 "d" 匹配，从而使整个表达式匹配成功。因此，结果是："\w+?" 匹配 "xxx"
</p>
<blockquote>
更多的情况，举例如下：
</blockquote>
<blockquote>
举例1：表达式 "&lt;td&gt;(.*)&lt;/td&gt;" 与字符串 "&lt;td&gt;&lt;p&gt;aa&lt;/p&gt;&lt;/td&gt; &lt;td&gt;&lt;p&gt;bb&lt;/p&gt;&lt;/td&gt;" 匹配时，匹配的结果是：成功；匹配到的内容是 "&lt;td&gt;&lt;p&gt;aa&lt;/p&gt;&lt;/td&gt; &lt;td&gt;&lt;p&gt;bb&lt;/p&gt;&lt;/td&gt;" 整个字符串， 表达式中的 "&lt;/td&gt;" 将与字符串中最后一个 "&lt;/td&gt;" 匹配。 
</blockquote>
<blockquote>
举例2：相比之下，表达式 "&lt;td&gt;(.*?)&lt;/td&gt;" 匹配举例1中同样的字符串时，将只得到 "&lt;td&gt;&lt;p&gt;aa&lt;/p&gt;&lt;/td&gt;"， 再次匹配下一个时，可以得到第二个 "&lt;td&gt;&lt;p&gt;bb&lt;/p&gt;&lt;/td&gt;"。
</blockquote>


<hr />

<p>
2.2 反向引用 \1, \2...
</p>
<blockquote>
表达式在匹配时，表达式引擎会将小括号 "( )" 包含的表达式所匹配到的字符串记录下来。在获取匹配结果的时候，小括号包含的表达式所匹配到的字符串可以单独获取。这一点，在前面的举例中，已经多次展示了。在实际应用场合中，当用某种边界来查找，而所要获取的内容又不包含边界时，必须使用小括号来指定所要的范围。比如前面的 "&lt;td&gt;(.*?)&lt;/td&gt;"。
</blockquote>
<blockquote>
其实，"小括号包含的表达式所匹配到的字符串" 不仅是在匹配结束后才可以使用，在匹配过程中也可以使用。表达式后边的部分，可以引用前面 "括号内的子匹配已经匹配到的字符串"。引用方法是 "\" 加上一个数字。"\1" 引用第1对括号内匹配到的字符串，"\2" 引用第2对括号内匹配到的字符串……以此类推，如果一对括号内包含另一对括号，则外层的括号先排序号。换句话说，哪一对的左括号 "(" 在前，那这一对就先排序号。
</blockquote>
<blockquote>
举例如下：
</blockquote>
<blockquote>
举例1：表达式 "('|")(.*?)(\1)" 在匹配 " 'Hello', "World" " 时，匹配结果是：成功；匹配到的内容是：" 'Hello' "。再次匹配下一个时，可以匹配到 " "World" "。
</blockquote>
<blockquote>
举例2：表达式 "(\w)\1{4,}" 在匹配 "aa bbbb abcdefg ccccc 111121111 999999999" 时，匹配结果是：成功；匹配到的内容是 "ccccc"。再次匹配下一个时，将得到 999999999。这个表达式要求 "\w" 范围的字符至少重复5次，注意与 "\w{5,}" 之间的区别。
</blockquote>
<blockquote>
举例3：表达式 "&lt;(\w+)\s*(\w+(=('|").<strong>?\4)?\s</strong>)<strong>&gt;.</strong>?&lt;/\1&gt;" 在匹配 "&lt;td id='td1' style="bgcolor:white"&gt;&lt;/td&gt;" 时，匹配结果是成功。如果 "&lt;td&gt;" 与 "&lt;/td&gt;" 不配对，则会匹配失败；如果改成其他配对，也可以匹配成功。
</blockquote>


<hr />

<p>
2.3 预搜索，不匹配；反向预搜索，不匹配
</p>
<blockquote>
前面的章节中，我讲到了几个代表抽象意义的特殊符号："^"，"$"，"\b"。它们都有一个共同点，那就是：它们本身不匹配任何字符，只是对 "字符串的两头" 或者 "字符之间的缝隙" 附加了一个条件。理解到这个概念以后，本节将继续介绍另外一种对 "两头" 或者 "缝隙" 附加条件的，更加灵活的表示方法。
</blockquote>
<blockquote>
正向预搜索："(?=xxxxx)"，"(?!xxxxx)"
</blockquote>
<blockquote>
格式："(?=xxxxx)"，在被匹配的字符串中，它对所处的 "缝隙" 或者 "两头" 附加的条件是：所在缝隙的右侧，必须能够匹配上 xxxxx 这部分的表达式。因为它只是在此作为这个缝隙上附加的条件，所以它并不影响后边的表达式去真正匹配这个缝隙之后的字符。这就类似 "\b"，本身不匹配任何字符。"\b" 只是将所在缝隙之前、之后的字符取来进行了一下判断，不会影响后边的表达式来真正的匹配。
</blockquote>
<blockquote>
举例1：表达式 "Windows (?=NT|XP)" 在匹配 "Windows 98, Windows NT, Windows 2000" 时，将只匹配 "Windows NT" 中的 "Windows "，其他的 "Windows " 字样则不被匹配。
</blockquote>
<blockquote>
举例2：表达式 "(\w)((?=\1\1\1)(\1))+" 在匹配字符串 "aaa ffffff 999999999" 时，将可以匹配6个"f"的前4个，可以匹配9个"9"的前7个。这个表达式可以读解成：重复4次以上的字母数字，则匹配其剩下最后2位之前的部分。当然，这个表达式可以不这样写，在此的目的是作为演示之用。
</blockquote>
<blockquote>
格式："(?!xxxxx)"，所在缝隙的右侧，必须不能匹配 xxxxx 这部分表达式。
</blockquote>
<blockquote>
举例3：表达式 "((?!\bstop\b).)+" 在匹配 "fdjka ljfdl stop fjdsla fdj" 时，将从头一直匹配到 "stop" 之前的位置，如果字符串中没有 "stop"，则匹配整个字符串。
</blockquote>
<blockquote>
举例4：表达式 "do(?!\w)" 在匹配字符串 "done, do, dog" 时，只能匹配 "do"。在本条举例中，"do" 后边使用 "(?!\w)" 和使用 "\b" 效果是一样的。
</blockquote>
<blockquote>
反向预搜索："(?&lt;=xxxxx)"，"(?&lt;!xxxxx)"
</blockquote>
<blockquote>
这两种格式的概念和正向预搜索是类似的，反向预搜索要求的条件是：所在缝隙的 "左侧"，两种格式分别要求必须能够匹配和必须不能够匹配指定表达式，而不是去判断右侧。与 "正向预搜索" 一样的是：它们都是对所在缝隙的一种附加条件，本身都不匹配任何字符。
</blockquote>
<blockquote>
举例5：表达式 "(?&lt;=\d{4})\d+(?=\d{4})" 在匹配 "1234567890123456" 时，将匹配除了前4个数字和后4个数字之外的中间8个数字。由于 JScript.RegExp 不支持反向预搜索，因此，本条举例不能够进行演示。很多其他的引擎可以支持反向预搜索，比如：Java 1.4 以上的 java.util.regex 包，.NET 中System.Text.RegularExpressions 命名空间，以及本站推荐的最简单易用的 DEELX 正则引擎。
</blockquote>


<hr />

<p>
3. 其他通用规则
</p>
<blockquote>
还有一些在各个正则表达式引擎之间比较通用的规则，在前面的讲解过程中没有提到。
</blockquote>

<p>
3.1 表达式中，可以使用 "\xXX" 和 "\uXXXX" 表示一个字符（"X" 表示一个十六进制数）
</p>

<p>
形式
 字符范围
</p>
 
<p>
\xXX
 编号在 0 ~ 255 范围的字符，比如：空格可以使用 "\x20" 表示
</p>
 
<p>
\uXXXX
 任何字符可以使用 "\u" 再加上其编号的4位十六进制数表示，比如："\u4E2D"
</p>
 

<p>
3.2 在表达式 "\s"，"\d"，"\w"，"\b" 表示特殊意义的同时，对应的大写字母表示相反的意义
</p>

<p>
表达式
 可匹配
</p>
 
<p>
\S
 匹配所有非空白字符（"\s" 可匹配各个空白字符）
</p>
 
<p>
\D
 匹配所有的非数字字符
</p>
 
<p>
\W
 匹配所有的字母、数字、下划线以外的字符
</p>
 
<p>
\B
 匹配非单词边界，即左右两边都是 "\w" 范围或者左右两边都不是 "\w" 范围时的字符缝隙
</p>
 

<p>
3.3 在表达式中有特殊意义，需要添加 "\" 才能匹配该字符本身的字符汇总
</p>

<p>
字符
 说明
</p>
 
<p>
^
 匹配输入字符串的开始位置。要匹配 "<sup><small>" 字符本身，请使用 "\</small></sup>"
</p>
 
<p>
$
 匹配输入字符串的结尾位置。要匹配 "\(" 字符本身，请使用 "\\)"
</p>
 
<p>
( )
 标记一个子表达式的开始和结束位置。要匹配小括号，请使用 "\(" 和 "\)"
</p>
 
<p>
[ ]
 用来自定义能够匹配 '多种字符' 的表达式。要匹配中括号，请使用 "\[" 和 "\]"
</p>
 
<p>
{ }
 修饰匹配次数的符号。要匹配大括号，请使用 "\{" 和 "\}"
</p>
 
<p>
.
 匹配除了换行符（\n）以外的任意一个字符。要匹配小数点本身，请使用 "\."
</p>
 
<p>
?
 修饰匹配次数为 0 次或 1 次。要匹配 "?" 字符本身，请使用 "\?".{0,1}
</p>
 
<p>
+
 修饰匹配次数为至少 1 次。要匹配 "+" 字符本身，请使用 "\+".{1,}
</p>
 
<p>
*
 修饰匹配次数为 0 次或任意次。要匹配 "<strong>" 字符本身，请使用 "\</strong>".{0,}
</p>
 
<p>
|
 左右两边表达式之间 "或" 关系。匹配 "|" 本身，请使用 "\|"
</p>
 

<p>
3.4 括号 "( )" 内的子表达式，如果希望匹配结果不进行记录供以后使用，可以使用 "(?:xxxxx)" 格式
</p>
<blockquote>
举例1：表达式 "(?:(\w)\1)+" 匹配 "a bbccdd efg" 时，结果是 "bbccdd"。括号 "(?:)" 范围的匹配结果不进行记录，因此 "(\w)" 使用 "\1" 来引用。
</blockquote>

<p>
3.5 常用的表达式属性设置简介：Ignorecase，Singleline，Multiline，Global
</p>

<p>
表达式属性
 说明
</p>
 
<p>
Ignorecase
 默认情况下，表达式中的字母是要区分大小写的。配置为 Ignorecase 可使匹配时不区分大小写。有的表达式引擎，把 "大小写" 概念延伸至 UNICODE 范围的大小写。
</p>
 
<p>
Singleline
 默认情况下，小数点 "." 匹配除了换行符（\n）以外的字符。配置为 Singleline 可使小数点可匹配包括换行符在内的所有字符。
</p>
 
<p>
Multiline
 默认情况下，表达式 "^" 和 "$" 只匹配字符串的开始 ① 和结尾 ④ 位置。如：
</p>

<p>
①xxxxxxxxx②\n
③xxxxxxxxx④
</p>

<p>
配置为 Multiline 可以使 "^" 匹配 ① 外，还可以匹配换行符之后，下一行开始前 ③ 的位置，使 "$" 匹配 ④ 外，还可以匹配换行符之前，一行结束 ② 的位置。
</p>
 
<p>
Global
 主要在将表达式用来替换时起作用，配置为 Global 表示替换所有的匹配。
</p>
 



<hr />


<p>
4. 其他提示
4.1 如果想要了解高级的正则引擎还支持那些复杂的正则语法，可参见本站 DEELX 正则引擎的说明文档。
</p>

<p>
4.2 如果要要求表达式所匹配的内容是整个字符串，而不是从字符串中找一部分，那么可以在表达式的首尾使用 "^" 和 "\("，比如："^\d+\)" 要求整个字符串只有数字。
</p>

<p>
4.3 如果要求匹配的内容是一个完整的单词，而不会是单词的一部分，那么在表达式首尾使用 "\b"，比如：使用 "\b(if|while|else|void|int……)\b" 来匹配程序中的关键字。
</p>

<p>
4.4 表达式不要匹配空字符串。否则会一直得到匹配成功，而结果什么都没有匹配到。比如：准备写一个匹配 "123"、"123."、"123.5"、".5" 这几种形式的表达式时，整数、小数点、小数数字都可以省略，但是不要将表达式写成："\d*\.?\d*"，因为如果什么都没有，这个表达式也可以匹配成功。更好的写法是："\d+\.?\d*|\.\d+"。
</p>

<p>
4.5 能匹配空字符串的子匹配不要循环无限次。如果括号内的子表达式中的每一部分都可以匹配 0 次，而这个括号整体又可以匹配无限次，那么情况可能比上一条所说的更严重，匹配过程中可能死循环。虽然现在有些正则表达式引擎已经通过办法避免了这种情况出现死循环了，比如 .NET 的正则表达式，但是我们仍然应该尽量避免出现这种情况。如果我们在写表达式时遇到了死循环，也可以从这一点入手，查找一下是否是本条所说的原因。
</p>

<p>
4.6 合理选择贪婪模式与非贪婪模式，参见话题讨论。
</p>

<p>
4.7 或 "|" 的左右两边，对某个字符最好只有一边可以匹配，这样，不会因为 "|" 两边的表达式因为交换位置而有所不同。
</p>


<hr />

<p>
5. 进阶与实战
</p>
<blockquote>
有了从本文中掌握的基础，我们可以从实践中进一步巩固我们使用正则表达式的技巧。
</blockquote>

<p>
5.1 下载正则表达式文档 chm 版本
</p>
<blockquote>
[ 点击下载 chm 版本] - DEELX 正则语法，包含其他高级语法的 chm 版本。
</blockquote>


<p>
5.2 下载正则工具 Regex Match Tracer 2.0 试用版（正版很值得购买）
</p>
<blockquote>
[ 下载 Match Tracer] - 471kb
</blockquote>


<p>
5.3 免费使用 Regex Match Tracer Web 版
</p>
<blockquote>
[ 使用 Match Tracer Web 版]
</blockquote>
<blockquote>
本 Web 版工具为免费使用，不受 Regex Match Tracer 主程序的试用期限制。
</blockquote>


<div class="foot">
<button id="back_to_topA" class="back_to_top" style='background-color:red'>返回顶部</button>

<a id="returnIndexA" href="d:\vim\vim\mysite\note_html\笔记整理.html" onclick="fun_a()">
<button id=returnIndex class="back_to_index">返回首页</button>
</a>



<HR SIZE=5>
<p class="left">
<!-- <div class="text" style=" text-align:center;font-size:15px"></div>-->
© <span id="year">2018</span> 
</p>
<script src="my.js"></script>
</div>
</div>
</body>
</html>
