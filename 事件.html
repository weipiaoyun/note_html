<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>

<link rel="Stylesheet" type="text/css" href="style.css">
<link rel="Stylesheet" type="text/css" href="styles/style.css">
<link rel="stylesheet" type="text/css" href="styles/codeStyles/shCore.css">
<link rel="stylesheet" type="text/css" href="styles/codeStyles/shThemeDefault.css">

<title>事件</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<script src="https://cdn.bootcss.com/jquery/3.3.1/jquery.min.js"></script>
</head>
<body>

<h2 id="toc_0.1">其它</h2>
<p>
F4属性旁边的其他就是事件，点击事件进入方法，传递的是两个参数：1，谁(哪个控件)触发的。2，执行需要的资源。
</p>

<h2 id="toc_0.2">委托和事件，函数的关系</h2>
<p>
	委托就是一个类型，和字符串一样，字符串类型，委托类型。委托类型的对象也是委托，如字符串类型的对象也是字符串一样。 事件就是委托类型的一个对象(一个是类，一个是对象)
</p>
	
<p>
	事件是特殊的委托，所以事件也是委托(事件的特殊点在于，1，不管申明为public的还是申明为private的，编译以后都是private的。只能在定义的类里面调用)，事件多了两个函数。add_MakeGreet和remove_MakeGreet。“+= ”对应 add_MakeGreet，“-=”对应remove_MakeGreet，一个是绑定，一个是删除。
</p>
	
<p>
	对委托进行加条件封装就是事件
</p>

<p>
	声明一个对象，对象里面的委托定义一个事件，在事件里面注册和添加方法名字(不用参数)。
</p>
	
<p>
	委托和方法的参数和返回值要相同
</p>
	
<p>
	一般情况下传递两个参数，一个是对象(事件源)(也就是事件所在的类定义的对象)，另一个是事件参数；
</p>
	
<p>
	通过把函数添加给事件，通过事件(事件其实就是个委托对象，通过委托执行执行)执行各个函数。
</p>
	
<p>
	典型例子是把函数传递给了button等控件。
</p>
	

<p>
	我们可以把事件编程简单地分成两个部分：事件发生的类（书面上叫事件发生器）和事件接收处理的类。
</p>
	

<p>
	MakeGreet事件确实是一个GreetingDelegate类型的委托，，
</p>
	
<p>
	窗体里面添加事件，只是注册方法，事件还有个执行过程。事件就是个委托对象。
</p>
	

<p>
	委托是一个类，事件是一个对象，特殊的(加了限制的)委托对象。
</p>
	
<p>
	事件的委托对象，不能=，只能+=，或者-=，事件的执行只能在定义的类中，即使是public。编译后都是private。
	普通委托对象可以=，可以+=，和-=，可以在类中执行，在public的情况下，也可以类外执行，不够安全。
</p>
	
<h1 id="toc_1">KeyDown</h1><HR SIZE=1>
<p>
if (e.Control &amp;&amp; e.KeyCode == Keys.F)
	MessageBox.Show("6666");
</p>

<h2 id="toc_1.1">按回车键</h2>
<p>
if (e.KeyCode != Keys.Enter)
{
}
</p>

<h1 id="toc_2">事件总线</h1><HR SIZE=1>
<p>
事件总线是观察者模式(发布-订阅)的一种实现。是一种集中式事件处理机制，允许不同的组件之间进行彼此通信而又不需要相互依赖，达到一种解耦的目的。
</p>

<p>
事件是由事件源(sender事件的对象和e事件参数)和事件处理。
</p>

<p>
发布方(Publisher)：被观察者，当状态改变时负责通知所有订阅者。在定义事件的类里面。
订阅方(subscriber)：观察者(多个),订阅时间对接收到的事件进行处理。在定义事件外的其他类里面。注册类。
</p>


<p>
发布订阅模式有两种实现方式：
	简单的实现方式：由publisher维护一个订阅者列表，当状态改变时循环遍历列表通知订阅者
	委托的方式实现：有PUblisher定义事件的委托，subscriber实现委托。
</p>
	
<p>
	发布订阅模式有两个关键字：通知和更新。
	被观察着(看有什么动作)的状态改变通知观察者做出相应的更新。
</p>
	


<p>
第一个问题：
</p>

<p>
事件总线最重要的作用就是解耦。
针对相同的事件，不同的订阅者有不同的处理方式。所以定义多个事件处理很正常。
</p>

<p>
第二个问题：
我可以理解你的问题是，对于同一个事件源，如何触发指定事件处理。
这个问题，在事件总线知多少（2）中有解答。
</p>

<p>
第三个问题：
不同的事件，要定义不同的事件源来进行区分
</p>

<h1 id="toc_3">发布订阅模式的实现机制</h1><HR SIZE=1>

<h1 id="toc_4">自定义事件</h1><HR SIZE=1>
<p>
1，定义一个委托。
2，定义一个事件，在类里面
3，为事件注册添加方法
4，类里面执行事件
</p>


<div class="foot">
<button id="back_to_topA" class="back_to_top" style='background-color:red'>返回顶部</button>

<a id="returnIndexA" href="d:\vim\vim\mysite\note_html\笔记整理.html" onclick="fun_a()">
<button id=returnIndex class="back_to_index">返回首页</button>
</a>



<HR SIZE=5>
<p class="left">
<!-- <div class="text" style=" text-align:center;font-size:15px"></div>-->
© <span id="year">2018</span> 
</p>
<script src="scripts/my.js"></script>
<script type="text/javascript" src="scripts/codeStyleScript/XRegExp.js"></script>
<script type="text/javascript" src="scripts/codeStyleScript/shCore.js"></script>
<script type="text/javascript" src="scripts/codeStyleScript/shBrushJava.js"></script>
<script type="text/javascript" src="scripts/codeStyleScript/shBrushJScript.js"></script>
<script type="text/javascript" src="scripts/codeStyleScript/shBrushSql.js"></script>
<script type="text/javascript" src="scripts/codeStyleScript/shBrushCSharp.js"></script>
<script type="text/javascript" src="scripts/codeStyleScript/shBrushCss.js"></script>
<script type="text/javascript" src="scripts/codeStyleScript/shBrushPerl.js"></script>
<script type="text/javascript" src="scripts/codeStyleScript/shBrushPerl.js"></script>
<script type="text/javascript" src="scripts/codeStyleScript/.js"></script>
<script type="text/javascript">
	SyntaxHighlighter.all()
</script>
</div>
</div>
</body>
</html>
