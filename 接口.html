<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<link rel="Stylesheet" type="text/css" href="style.css">
<title>接口</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<script src="https://cdn.bootcss.com/jquery/3.3.1/jquery.min.js"></script>
</head>
<body>

<p>
<a href="IEnumerable接口.html">IEnumerable接口</a><br>
</p>

<p>
1, 接口肯定是public的，所以没必要添加公共还是私有修饰词
2，指示申明函数，不定义。
</p>

<h1 id="toc_1">实现过程</h1>
<p>
1，定义接口类型(IRar)
2，A类继承该接口，B类继承该接口(Rar4Dg, Rar4Sz, Rar4Mz)
3，定义接口调用，传递实现该接口的类对象，赋值给接口。实现该类对象的方法。(Rar)
</p>

<p>
实现用接口类型对象去实现(所有继承该接口的类都一样)，实际调用的是各个类的对象方法，从而实现对不同类型，实现不同方法，也就是多态。
</p>

<h1 id="toc_2">接口对象 </h1>
<p>
接口的引用指向实现它的类的对象
</p>


<p>
对一组方法签名进行了统一命名，但不提供方法的实现
CLR允许一个类继承多个接口，不允许继承多个类。
</p>


<p>
C# 编译器要求接口方法标记为public
CLR要求接口定义标记为virtual，如果不显式标记为virtual，则默认标记为virtual，且为sealed。派生出来的类无法重写该接口方法。显式标记为virtual，则派生出来的类可以重写该接口方法。
</p>

<p>
派生类可以重新继承同一个接口。并为接口的方法提供具体的实现。对象的调用方法，是该对象的类型中的实现。
</p>

<p>
没有in/out关键字，是不能逆变或协变的.
目前仅接口和委托支持协变和逆变，不支持类和方法。数组也有协变性
值类型不能协变或逆变。
</p>



<p>
接口的作用对于很多新手来说很不容易理解，我给大家举个例子。接口只是一个规范，所以里面的方法都是空的。假如我开了一个宠物粮店，声明所有宠物都可以来我这里买粮食，这就相当于一个接口，public interface PetRestaurant { public void buy();}当一只狗看到了，知道自己是宠物，所以它去实现这个接口public class DogPet implements PetRestaurant { @Override public void buy() {  System.out.println("我是狗，我要买狗粮"); }}当一只猫看到了，知道自己也是宠物，所以也去实现这个接口public class CatPet implements PetRestaurant { @Override public void buy() {  System.out.println("我是猫，我要买猫粮"); }}当狗和猫来我的店之前，我是不知道他们到底是什么，但是当他们来到我的店，我就知道一个要猫粮食，一个要狗粮食。因为他们都实现了 我这个接口，都可以买。下面这个类相当于一个接待顾客的类，即店小二，他接待所有实现了我这个宠物店接口的动物，传进来一个PetRestaurant 类型的宠物，注意，这个PetRestaurant 是接口public class test { public void buy(PetRestaurant pet) {  pet.buy(); }}好了，这个时候我这个老板出现了，我可以给他们卖粮食了，相当于测试类public class Tests { public static void main(String[] args) {  PetRestaurant dog = new DogPet();  //实例化一个狗，相当于把狗顾客实例化  PetRestaurant cat = new CatPet();//实例化一个猫，相当于把猫顾客实例化  test t = new test();  //实例化一个店小二  t.buy(cat);  //把猫交给店小二  t.buy(dog); //把狗交给店小二 }}这样运行的结果就是我是猫，我要买猫粮我是狗，我要买狗娘你知道吗，整个过程我这个店主其实根本不知道来的到底是猫是狗还是其他什么，我只要有一个店小二，把这些来的不知什么动物都全部交给店小二，店小二就知道怎么去卖了，因为这些狗啊猫啊都实现了我这个宠物店的接口，而店小二就负责接待所有实现了我这个接口的动物。这就有一个好处，假如明天来了一头小猪，只要它实现了我这个接口，我只管交给店小二处理就OK了，我这个店小二根本不需要变化，我这个店主也只需要实例化一下这个动物就OK你想，假如没有接口，会怎么办，来一个猫，我要去创造一个猫，还要实例化，来一只狗，我要创建一只狗，同样要实例化，还要配备专门的店小二去接待，就会相当麻烦
</p>

<button class="back_to_top">返回顶部</button>
<script src="my.js"></script>
<HR SIZE=5>
<p class="left">
<!-- <div class="text" style=" text-align:center;font-size:15px"></div>-->
© <span id="year">2018</span> 惟飘云-不忘初心!砥砺前行
</p>
</body>
</body>
</html>
