<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>

<link rel="Stylesheet" type="text/css" href="style.css">
<link rel="Stylesheet" type="text/css" href="styles/style.css">
<link rel="stylesheet" type="text/css" href="styles/codeStyles/shCore.css">
<link rel="stylesheet" type="text/css" href="styles/codeStyles/shThemeDefault.css">

<title>计算机网络</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<script src="https://cdn.bootcss.com/jquery/3.3.1/jquery.min.js"></script>
</head>
<body>

<div class="toc">
<ul>
<li><a href="#toc_1">计算机网络分类 </a>
<li><a href="#toc_2">IP地址表示 </a>
<li><a href="#toc_3">IP </a>
<li><a href="#toc_4">IPv6 </a>
<ul>
<li><a href="#toc_4.1">数据包 </a>
</ul>
<li><a href="#toc_5">网络设备 </a>
<ul>
<li><a href="#toc_5.1">路由器 </a>
<li><a href="#toc_5.2">网桥 </a>
<li><a href="#toc_5.3">交换机 </a>
</ul>
<li><a href="#toc_6">虚拟机的桥接和NAT模式 </a>
<ul>
<li><a href="#toc_6.1">linux虚拟网卡 </a>
<li><a href="#toc_6.2">vmware的几个虚拟设备 </a>
<ul>
<li><a href="#toc_6.2.1">虚拟交换机 </a>
<li><a href="#toc_6.2.2">虚拟网卡(网络适配器) </a>
</ul>
</ul>
<li><a href="#toc_7">linux网络命令 </a>
<li><a href="#toc_8">VPN</a>
<ul>
<li><a href="#toc_8.1">端口号</a>
<li><a href="#toc_8.2">socket端口</a>
<li><a href="#toc_8.3">TCP的三次握手</a>
<li><a href="#toc_8.4">TCP和UDP协议</a>
<li><a href="#toc_8.5">局域网</a>
<li><a href="#toc_8.6">广播地址</a>
<li><a href="#toc_8.7">NAT模式和桥接模式</a>
</ul>
<li><a href="#toc_9">子网掩码</a>
<li><a href="#toc_10">网关</a>
<li><a href="#toc_11">DNS</a>
<li><a href="#toc_12">IP地</a>
<ul>
<li><a href="#toc_12.1">DHCP</a>
<li><a href="#toc_12.2">如何根据ping的IP知道是什么操作系统</a>
</ul>
<li><a href="#toc_13">问题 </a>
<ul>
<li><a href="#toc_13.1">为什么有IP地址还要有MAC地址 </a>
</ul>
</ul>
</div>
<div class="content" style="margin-left:20%;padding:1px 16px;height:1000px;">

<h1 id="toc_1">计算机网络分类 </h1><HR SIZE=1>
<p>
<div class="Img"><img src="file://D:\vim\vim\mysite\note/images/ipClassify.JPEG" /></div>
ipClassify.jpeg
</p>
<h1 id="toc_2">IP地址表示 </h1><HR SIZE=1>
<p>
172.18.3.231/16
16表示的是网络码占用16位，可以有65534个主机(2^16-2)。表示子网掩码为255.255.0.0
</p>

<p>
IPv6地址后的百分号:
</p>

<p>
ksldfj
</p>

<p>
对于连入网络但没有IPv6路由器或DHCPv6服务器的IPv6客户端，它们始终使用fe80::/64链路本地网络地址。如果运行Windows的计算机中有多个网络适配器连接到不同的网段，可以在IP地址后加百分号和区域ID数字来区分不同的网络，如下所示：
</p>

<p>
■ fe80::d84b:8939:7684:a5a4%7
</p>

<p>
■ fe80::462:7ed4:795b:1c9f%8
</p>

<p>
■ fe80::2882:29d5:e7a4:b481%9
</p>

<p>
最后两个字符分别表示前面网络所连接的区域ID是 7、8和9。当连接链路本地地址时，应该始终指定区域ID。区域ID与接口索引值相同，当基于每个接口配置IPv6设置时通常会用到该索引值。
</p>

<p>
注意区域ID相对于发送主机，因此，不同的主机连入同一个网络可能会使用不同的区域ID来标识该网络。
</p>

<p>
在Asp.net编程中，客户端使用了IPv6，在服务器端获取remote_addr时会获取形如 fe80::d84b:8939:7684:a5a4%7的机器主机，把该地址写入客户端时要注意把%替换掉，否则可能会出现一些html编码问题。
</p>

<h1 id="toc_3">IP </h1><HR SIZE=1>

<p>
　　作用：有助于数据进出介质。
</p>

<p>
　　封装成帧(framing)就是在一段数据的前后分别添加首部和尾部，这样就构成了一个帧。LM2591HVSX-ADJ接收端在收到物理层上交的比特流后，就能根据首部和尾部的标记，从收到的比特流中识别帧的开始和结束。
</p>

<p>
　　图3-4表示用帧首部和帧尾部封装成帧的一般概念。
所有在因特网上传送的数据都是以分组（即lP数据报）为传送单位的。
</p>

<p>
网络层的IP数据报传送到数据链路层就成为帧的数据部分。
在帧的数据部分的前面和后面分别添加上首部和尾部，构成了一个完整的帧。
</p>

<p>
这样的帧就是数据链路层的数据传送单元。
</p>

<p>
一个帧的帧长等于帧的数据部分长度加上帧首部和帧尾部的长度。
</p>

<p>
首部和尾部的一个重要作用就是进行帧定界（即确定帧的界限）。
</p>

<p>
　　此外，首部和尾部还包括许多必要的控制信息。
</p>


<p>
在发送帧时，是从帧首部开始发送。
</p>

<p>
各种数据链路层协议都对帧首部和帧尾部的格式有明确的规定：
</p>

<p>
为了提高帧的传输效率，应当使帧的数据部分长度尽可能地大于首部和尾部的长度。
</p>

<p>
1、数据链路层对数据帧的长度都有一个限制，也就是链路层所能承受的最大数据长度，这个值
称为最大传输单元，即MTU。以以太网为例，这个值通常是1500字节。
</p>

<ol>
<li>
数据链路层对数据帧的长度都有一个限制，也就是链路层所能承受的最大数据长度，这个值

</ol>
<p>
称为最大传输单元，即MTU。以以太网为例，这个值通常是1500字节。
</p>
<ol>
<li>
对于IP数据包来讲，也有一个长度，在IP包头中，以16位来描述IP包的长度。一个IP包，最长可能是65535字节。

<li>
结合以上两个概念，第一个重要的结论就出来了，如果IP包的大小，超过了MTU值，那么就需要

</ol>
<p>
分片，也就是把一个IP包分为多个，这个概念非常容易理解，一个载重5T的卡车，要拉10T的货，它
当然就得分几次来拉了。
</p>

<p>
当然，结论是显而易见的，这个数据包会被再次分片，咱开始用火车拉，到了半路，不通火车，只通汽车，那一车货会被分为很多车……仅此而已，更重要的是，这种情况下，如果IP包被设置了“不允许分片标志”，那会发生些什么呢？对，数据包将被丢弃，然后收到一份ICMP不可达差错，告诉你，需要分片！这个网络中最小的MTU值，被称为路径MTU，我们应该有一种有效的手段，来发现这个值，最笨的方法或许是先用traceroute查看所有节点，然后一个个ping……
</p>

<p>
每一种链路层协议都规定了所能传送的帧的数据部分长度上限
——最大传送单元MTU (Maximum Transfer Unit)
图3-4给出了帧的首部和尾部的位置，以及帧昀数据部分与MTU的关。
</p>

<p>
标准的以太网帧——目的ip、源ip、类型、数据报、FCS。
</p>

<h1 id="toc_4">IPv6 </h1><HR SIZE=1>
<p>
ip地址2进制为128位。可以表示2^128个数据。
如果用16进制表示。一个十六进制需要4个二进制表示。所以需要128/4=32个16进制表示。一组有4个16进制。所以需要8组。所以。
128位。8组，每组4个16进制表示IP地址。
X:X:X:X:X:X:X:X 8组，每组四个十六进制的数字标志(即每个X有四个FFFF)
每组前面的0可以省略。后面的0不能省略
2001:0:0:0:0:8:800:201C:417A
=2001::8:800:201C:417A
每一组数值前面的 0 可以省略。如 0008 写成 8 。
</p>




<h2 id="toc_4.1">数据包 </h2>
<p>
data packet
数据包也是分组交换的一种形式
就是把所传送的数据分段打成 “包”，再传送出去。(打包)
</p>

<p>
各个数据包不一定都通过同一条路径传输，所以叫做“无连接型”
</p>

<p>
每个数据包都有报头和报文这两个部分
	报头：报头中有目的地址等必要内容，使每个数据包不经过同样的路径都能准确地到达目的地
	要求IP具有分组打包和集合组装的功能。
</p>
	

<p>
分片和重组
</p>

<p>
	重新组装(由目的地的IP层来完成)
</p>

<h1 id="toc_5">网络设备 </h1><HR SIZE=1>
<h2 id="toc_5.1">路由器 </h2>
<p>
路由也是数据包的中继站， 路由器是用来帮用户IP包寻找目的地在哪里的！
</p>

<p>
在一定的幅度内（阀值）信号变形，是可以识别的，而如果无法识别，就会造成0、1 换位，这种错误可以在数据链路层CRC来发现、并丢弃！
</p>

<h2 id="toc_5.2">网桥 </h2>
<p>
作用，两个相似的网络连接起来，扩展网络距离和范围。提高网络性能。，数据锅炉(不是该该网段的才转发)
在数据链路层
</p>

<p>
网桥工作在数据链路层，将两个LAN连起来，根据MAC地址来转发帧，可以看作一个“低层的路由器”（路由器工作在网络层，根据网络地址如IP地址进行转发）。
</p>

<h2 id="toc_5.3">交换机 </h2>
<p>
1
</p>

<h1 id="toc_6">虚拟机的桥接和NAT模式 </h1><HR SIZE=1>
<h2 id="toc_6.1">linux虚拟网卡 </h2>
<p>
vnet0：虚拟机里面的网络适配器
vnet1：虚拟机里面的另一个网络适配器。双网卡
</p>

<h2 id="toc_6.2">vmware的几个虚拟设备 </h2>
<h3 id="toc_6.2.1">虚拟交换机 </h3>
<p>
VMnet0：用于虚拟桥接网络下的虚拟交换机(虚拟网桥)
VMnet1：用于虚拟Host-Only网络下的虚拟交换机
VMnet8：用于虚拟NAT网络下的虚拟交换机
</p>

<h3 id="toc_6.2.2">虚拟网卡(网络适配器) </h3>
<p>
VMware NetworkAdepter VMnet1：Host用于与Host-Only虚拟网络进行通信的虚拟网卡
VMware NetworkAdepter VMnet8：Host用于与NAT虚拟网络进行通信的虚拟网卡
桥接模式不用虚拟网卡
</p>



<p>
桥接：
物理网卡&lt;-VMnet0虚拟网桥-&gt;虚拟网卡
</p>

<p>
linux桥接：
	yum install bridge-utils
	vim /etc../ifcfg-br0
	brctl addif br0 eth0
	/sbin/service network restart
	98注意网关，否则无法访问172
</p>
	
	
<p>
NAT：
VMware NetworkAdepter VMnet8虚拟网卡&lt;-VMnet8虚拟交换机-&gt;虚拟机虚拟网卡
98
	NAT模式，一个物理网卡192ip(不用新添加ip)
	虚拟机的虚拟网卡和通过虚拟路由和cam98的虚拟网卡连接。cam98的虚拟网卡和物理网卡通过NAT转换。
</p>

<p>
07
	桥接模式，一个物理网卡172，一个192
	设置br0,172.17.100.100。虚拟机172.17.100.101(多了两个172ip)，网关172.17.1.98
	虚拟机通过br0，连接虚拟机的虚拟网卡和07的物理网卡。
</p>
	

<p>
97
	桥接模式，一个物理网卡192ip
	br0 192.168.6.112，虚拟机192.168.6.197。(也是多了两个ip)，网关192.168.6.254
</p>
	
	
<h1 id="toc_7">linux网络命令 </h1><HR SIZE=1>
<p>
/sbin/ethtool eth0 | grep Link。
</p>


<p>
<a href="公司网络.html">公司网络</a>
<a href="linux网络与共享.html">linux网络与共享</a>
<a href="linux防火墙.html">linux防火墙</a>
<a href="七层模型and网络数据包.html">七层模型and网络数据包</a>
<a href="套接字.html">套接字</a>
</p>
<h1 id="toc_8">VPN</h1><HR SIZE=1>
<p>
linux网络流量实时监控工具之iptraf
</p>


<h2 id="toc_8.1">端口号</h2>
<p>
在网络技术中，端口（Port）包括逻辑端口和物理端口两种类型。物理端口指的是物理存在的端口，如ADSL Modem、集线器、交换机、路由器上用 于连接其他网络设备的接口，如RJ-45端口、SC端口等等。逻辑端口是指逻辑意义上用于区分服务的端口，如TCP/IP协议中的服务端口，端口号的范围从0到65535，比如用于浏览网页服务的80端口，用于FTP服务的21端口等。由于物理端口和逻辑端口数量较多，为了对端口进行区分，将每个端口进行了编号，这就是端口号。
</p>

<h2 id="toc_8.2">socket端口</h2>
<p>
客户端如果要访问服务端的应用程序，必须经过服务器的socket端口(负责监听的socket)
</p>

<h2 id="toc_8.3">TCP的三次握手</h2>
<p>
客户端  -》你有空？-》服务端
服务端-》有-》客户端
客户端-》知道-》服务端
</p>

<h2 id="toc_8.4">TCP和UDP协议</h2>
<p>
TCP协议:有3次握手，安全、稳定、但是效率低。
UDP协议：快速、效率高、但是不稳定，容易发生数据丢失。
</p>


<h2 id="toc_8.5">局域网</h2>
<p>
LAN：
	范围：几米到10公里范围内。一般在一个建筑物或一个单位内
</p>
	
<p>
	不存在寻径问题，不包括网络层应用
</p>
	
<p>
MAN：
	范围：10到100公里。由多个LAN组成，用光纤连接
</p>
	
<p>
WAN：
	范围：几百到几千公里
</p>
	
<p>
计算机网络协议：
	分层式的：各个层直接互相独立，互不干扰，之间只用层间接口提供服务。
</p>

<p>
连接
</p>

<h2 id="toc_8.6">广播地址</h2>
<p>
广播地址是主机号全是1的地址(所有同网络所有主机的地址，向广播地址发送信息的时候，发送给同网段的所有主机)，如172.18.0.0段的IP，则广播地址为172.18.255.255.192.168.8.0段的ip，广播地址为192.168.8.255
</p>

<p>
在段里面全是0的和全是1的都不能作为正式的ip地址
</p>

<h2 id="toc_8.7">NAT模式和桥接模式</h2>
<p>
NAT(Network Address Translation)模式是网络地址转换的形式，网络经过主机
桥接模式：把虚拟机当作是局域网中独立的主机对待，和其他主机具有相同的地位
</p>

<h1 id="toc_9">子网掩码</h1><HR SIZE=1>
<p>
子网掩码的作用就是用来判断任意两个IP地址是否属于同一子网络
</p>

<h1 id="toc_10">网关</h1><HR SIZE=1>
<p>
gateway：两个网络之间连接的关口
通常指的网关就是路由器的IP
网关实质上是一个网络通向其他网络的IP地址
那么网关到底是什么呢？网关实质上是一个网络通向其他网络的IP地址。比如有网络A和网络B，网络A的IP地址范围为“192.168.1.1~192. 168.1.254”，子网掩码为255.255.255.0；网络B的IP地址范围为“192.168.2.1~192.168.2.254”，子网掩码为255.255.255.0。在没有路由器的情况下，两个网络之间是不能进行TCP/IP通信的，即使是两个网络连接在同一台交换机（或集线器）上，TCP/IP协议也会根据子网掩码（255.255.255.0）判定两个网络中的主机处在不同的网络里。而要实现这两个网络之间的通信，则必须通过网关。如果网络A中的主机发现数据包的目的主机不在本地网络中，就把数据包转发给它自己的网关，再由网关转发给网络B的网关，网络B的网关再转发给网络B的某个主机（如附图所示）。网络A向网络B转发数据包的过程。
</p>

<p>
网关也被称为 IP路由器。
</p>

<p>
子网掩码和IP相与得出来的结果如果是一样，则是统一网络，否则不同网络
</p>

<h1 id="toc_11">DNS</h1><HR SIZE=1>
<p>
domain name system  域名系统
其实就是一个分布式的数据库
作用：使用户更加方便地使用互联网
域名解析(也叫主机名解析)：通过主机名，获得该主机名对应的IP地址
协议：运行在UDP协议之上
端口号：53
</p>

<p>
主机名到IP的映射方法：
1，静态映射：每台设备都配置主机到IP地址的映射。各设备独立维护自己的映射表，而且只供本设备使用。
2，动态映射：建立一套域名解析系统(DNS)，只在专门的DNS服务器上配置主机到IP地址的映射。
</p>


<h1 id="toc_12">IP地</h1><HR SIZE=1>
<p>
我们知道IP地址是一个4字节（共32bit）的数字，被分为4段，每段8位，段与段之间用句点分隔。
为了便于表达和识别，IP地址是以十进制形式表示的如210.52.207.2，
每段所能表示的十进制数最大不超过255。
IP地址由两部分组成，即网络号（Netgwork ID）和主机号（Host ID）。
网络号标识的是Internet上的一个子网，而主机号标识的是子网中的某台主机。
网际地址分解成两个域后，带来了一个重要的优点：IP数据包从网际上的一个网络到达另一个网络时，选择路径可以基于网络而不是主机。在大型的网际中，这一点优势特别明显，因为路由表中只存储网络信息而不是主机信息，这样可以大大简化路由表。IP地址根据网络号和主机号的数量而分为A、B、C三类：A类IP地址：用7位（bit）来标识网络号，24位标识主机号，最前面一位为"0"，即A类地址的第一段取值介于1～126之间。A类地址通常为大型网络而提供，全世界总共只有126个只可能的A类网络，每个A类网络最多可以连接16777214台主机。B类IP地址：用14位来标识网络号，16位标识主机号，前面两位是"10"。B类地址的第一段取值介于128～191之间，第一段和第二段合在一起表示网络号。B类地址适用于中等规模的网络，全世界大约有16000个B类网络，每个B类网络最多可以连接65534台主机。C类IP地址：用21位来标识网络号，8位标识主机号，前面三位是"110"。C类地址的第一段取值介于192～223之间，第一段、第二段、第三段合在一起表示网络号。最后一段标识网络上的主机号。C类地址适用于校园网等小型网络，每个C类网络最多可以有254台主机。从上面的介绍我们知道，IP地址是以网络号和主机号来标示网络上的主机的，只有在一个网络号下的计算机之间才能"直接"互通，不同网络号的计算机要通过网关（Gateway）才能互通。但这样的划分在某些情况下显得并十分不灵活。为此IP网络还允许划分成更小的网络，称为子网（Subnet），这样就产生了子网掩码。子网掩码的作用就是用来判断任意两个IP地址是否属于同一子网络，这时只有在同一子网的计算机才能"直接"互通。那么怎样确定子网掩码呢？前面讲到IP地址分网络号和主机号，要将一个网络划分为多个子网，因此网络号将要占用原来的主机位，如对于一个C类地址，它用21位来标识网络号，要将其划分为2个子网则需要占用1位原来的主机标识位。此时网络号位变为22位为主机标示变为7位。同理借用2个主机位则可以将一个C类网络划分为4个子网……那计算机是怎样才知道这一网络是否划分了子网呢？这就可以从子网掩码中看出。子网掩码和IP地址一样有32bit，确定子网掩码的方法是其与IP地址中标识网络号的所有对应位都用"1"，而与主机号对应的位都是"0"。如分为2个子网的C类IP地址用22位来标识网络号，则其子网掩码为：11111111 11111111 11111111 10000000即255.255.255.128。于是我们可以知道，A类地址的缺省子网掩码为255.0.0.0,B类为255.255.0.0,C类为255.255.255.0。下表是C类地址子网划分及相关子网掩码：子网位数 子网掩码 主机数 可用主机数  1 255.255.255.128 128 126  2 255.255.255.192 64 62  3 255.255.255.224 32 30  4 255.255.255.240 16 14  5 255.255.255.248 8 6  6 255.255.255.252 4 2你可能注意到上表分了主机数和可用主机数两项，这是为什么呢？因为但当地址的所有主机位都为"0"时，这一地址为线路（或子网）地址，而当所有主机位都为"1"时为广播地址。同时我们还可以使用可变长掩码（VLSM）就是指一个网络可以用不同的掩码进行配置。这样做的目的是为了使把一个网络划分成多个子网更加方便。在没有VLSM的情况下，一个网络只能使用一种子网掩码，这就限制了在给定的子网数目条件下主机的数目。例如你被分配了一个C类地址，网络号为192.168.10.0,而你现在需要将其划分为三个子网,其中一个子网有100台主机,其余的两个子网有50台主机。我们知道一个C类地址有254个可用地址，那么你如何选择子网掩码呢？从上表中我们发现，当我们在所有子网中都使用一个子网掩码时这一问题是无法解决的。此时VLSM就派上了用场，我们可以在100个主机的子网使用255.255.255.128这一掩码，它可以使用192.168.10.0到192.168.10.127这128个IP地址，其中可用主机号为126个。我们再把剩下的192.168.10.128到192.168.10.255这128个IP地址分成两个子网，子网掩码为255.255.255.192。其中一个子网的地址从192.168.10.128到192.168.10.191,另一子网的地址从192.168.10.192到192.168.10.255。子网掩码为255.255.255.192每个子网的可用主机地址都为62个，这样就达到了要求。可以看出合理使用子网掩码，可以使IP地址更加便于管理和控制。（肖秋涛）
</p>

<p>
，只有在一个网络号下的计算机之间才能"直接"互通
址
</p>

<h2 id="toc_12.1">DHCP</h2>
<p>
动态主机配置协议,局域网的网络协议,使用UDP协议工作,自动分配IP地址，给用户或者内部网络管理员作为对所有计算机作中央管理的手段,DHCP有3个端口，其中UDP67和UDP68为正常的DHCP服务端口，分别作为DHCP Server和DHCP Client的服务端口；546号端口用于DHCPv6 Client，而不用于DHCPv4，是为DHCP failover服务，这是需要特别开启的服务，DHCP failover是用来做“双机热备”的。
</p>


<h2 id="toc_12.2">如何根据ping的IP知道是什么操作系统</h2>
<p>
Time To Live (TTL) 域的信息很有趣。每一个被发送出的IP信息包都有一个TTL域，该域被设置为一个较高的数值（在本例中ping信息包的TTL值为255)。当信息包在网络中被传输时，TTL的域值通过一个路由器时递减1；当TTL 递减到0时，信息包被路由器抛弃。
</p>

<p>
IP规范规定：TTL应该被设置为60 (尽管ping 信息包的TTL是255)。这样做主要是为了让一个信息包永远在为了中存在。担该信息对我们来说有特殊的含义。我们可以使用TTL大致确定该信息包经过了多少个路由器过渡段。在本例中，用255减去N，N是返回的回送答复的TTL。如果TTL值在连续几个ping中发生变化，这说明返回的信息包经过了不同的路由器。
</p>

<p>
time显示了信息包到达远程主机后返回的时间。计算定位为毫秒。通常网卡下，来回时间在200毫秒以下最好。信息包抵达目的地的时间叫做latency（等待时间），如果你看到来回时间变化很大（叫做"jitter（抖动）），这说明同主机之间的联接状况很差。但是如果在较大抽样范围（50到100）内出现几个这样的情况也不必担心。
</p>

<p>
要退出ping, 则键入control-c。这激昂中止该程序并打印总结：有多少信息包被传输，有多少信息包被接收到，丢失的信息包的比例，以及信息包来回时间的最低、最高和平均值。
</p>

<p>
ping是测试为了联接状况以及信息包发送和接收状况非常有用的工具。
</p>

<p>
对应的TTL值有什么特别的含意呢？
</p>

<p>
ttl每经过一个ip子层就减少1
</p>

<p>
UNIX 及类 UNIX 操作系统 ICMP 回显应答的 TTL 字段值为 255
</p>

<p>
Compaq Tru64 5.0 ICMP 回显应答的 TTL 字段值为 64
</p>

<p>
微软 Windows NT/2K操作系统 ICMP 回显应答的 TTL 字段值为 128
</p>

<p>
微软 Windows 95 操作系统 ICMP 回显应答的 TTL 字段值为 32
</p>

<p>
当然，返回的TTL值是相同的
</p>

<p>
但有些情况下有所特殊
</p>

<p>
LINUX Kernel 2.2.x &amp; 2.4.x ICMP 回显应答的 TTL 字段值为 64
</p>

<p>
FreeBSD 4.1, 4.0, 3.4;
Sun Solaris 2.5.1, 2.6, 2.7, 2.8;
OpenBSD 2.6, 2.7,
NetBSD
HP UX 10.20
ICMP 回显应答的 TTL 字段值为 255
</p>

<p>
Windows 95/98/98SE
Windows ME
ICMP 回显应答的 TTL 字段值为 32
</p>

<p>
Windows NT4 WRKS
Windows NT4 Server
Windows 2000
ICMP 回显应答的 TTL 字段值为 128
</p>

<p>
这样，我们就可以通过这种方法来辨别
</p>

<p>
操作系统 TTL
LINUX 64
WIN2K/NT 128
WINDOWS 系列 32
UNIX 系列 255
</p>

<h1 id="toc_13">问题 </h1><HR SIZE=1>
<h2 id="toc_13.1">为什么有IP地址还要有MAC地址 </h2>
<p>
如果只有MAC。则因为设备是移动的。很难定位。而IP是运营商管理的。很快可以定位到固定位置。所以需要IP。
</p>

<p>
一个IP可以多台设备使用。如果两台电脑用同个ip。明显冲突，但找不到具体哪台(无法锁定哪台计算机哪台设备)。所以需要每台电脑有固定的地址。所以需要MAC地址。
</p>


<p>
每台设备需要固定的地址。固定的地址不能很好的定位。所以需要两个地址。
</p>


<div class="foot">
<button id="back_to_topA" class="back_to_top" style='background-color:red'>返回顶部</button>

<a id="returnIndexA" href="d:\vim\vim\mysite\note_html\笔记整理.html" onclick="fun_a()">
<button id=returnIndex class="back_to_index">返回首页</button>
</a>



<HR SIZE=5>
<p class="left">
<!-- <div class="text" style=" text-align:center;font-size:15px"></div>-->
© <span id="year">2018</span> 
</p>
<script src="scripts/my.js"></script>
<script type="text/javascript" src="scripts/codeStyleScript/XRegExp.js"></script>
<script type="text/javascript" src="scripts/codeStyleScript/shCore.js"></script>
<script type="text/javascript" src="scripts/codeStyleScript/shBrushJava.js"></script>
<script type="text/javascript" src="scripts/codeStyleScript/shBrushJScript.js"></script>
<script type="text/javascript" src="scripts/codeStyleScript/shBrushSql.js"></script>
<script type="text/javascript" src="scripts/codeStyleScript/shBrushCSharp.js"></script>
<script type="text/javascript" src="scripts/codeStyleScript/shBrushCss.js"></script>
<script type="text/javascript" src="scripts/codeStyleScript/shBrushPerl.js"></script>
<script type="text/javascript" src="scripts/codeStyleScript/shBrushPerl.js"></script>
<script type="text/javascript" src="scripts/codeStyleScript/.js"></script>
<script type="text/javascript">
	SyntaxHighlighter.all()
</script>
</div>
</div>
</body>
</html>
