<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<link rel="Stylesheet" type="text/css" href="style.css">
<title>数据库</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<script src="https://cdn.bootcss.com/jquery/3.3.1/jquery.min.js"></script>
</head>
<body>

<h1>目录：</h1>
<div class="toc">
<ul>
<li><a href="#toc_1">飞伟 </a>
<li><a href="#toc_2">C#连接数据库</a>
<li><a href="#toc_3">varchar和nvarchar</a>
<ul>
<li><a href="#toc_3.1">占的字节数不同</a>
</ul>
<li><a href="#toc_4">编辑前200行里面</a>
<li><a href="#toc_5">顺序</a>
<ul>
<li><a href="#toc_5.1">预备多条查询语句应对不同情况</a>
</ul>
<li><a href="#toc_6">表联接</a>
<li><a href="#toc_7">union和unionall</a>
<li><a href="#toc_8">库由表组成</a>
<ul>
<li><a href="#toc_8.1">windows 启动mysql</a>
<li><a href="#toc_8.2">linux 如何启动/停止/重启MySQL</a>
<ul>
<li><a href="#toc_8.2.0.1">如何进入mysql</a>
<li><a href="#toc_8.2.0.2">数据库操作</a>
<li><a href="#toc_8.2.0.3">表操作</a>
</ul>
</ul>
<li><a href="#toc_8.3">显示表：</a>
<li><a href="#toc_8.4">创建表</a>
<li><a href="#toc_8.5">删除表</a>
<li><a href="#toc_8.6">删除表(某记录 行)内容：</a>
<li><a href="#toc_8.7">插入表</a>
<li><a href="#toc_8.8">更改表内容</a>
<li><a href="#toc_8.9">查看表结构</a>
<li><a href="#toc_8.10">查询表(输出表内容(字段内容:由一个字段的值获取另一个字段的值))</a>
</ul>
<li><a href="#toc_9">left join right join inner join</a>
<li><a href="#toc_10">聚合函数</a>
<li><a href="#toc_11">group by 分组，各个</a>
<ul>
<li><a href="#toc_11.1">having</a>
</ul>
<li><a href="#toc_12">order by</a>
<li><a href="#toc_13">asc desc</a>
<li><a href="#toc_14">limit</a>
<li><a href="#toc_15">求取某一部门的工资最低值</a>
<ul>
<li><a href="#toc_15.0.0.1">执行语句</a>
<li><a href="#toc_15.0.0.2">字符集的概念(库)</a>
</ul>
</ul>
<li><a href="#toc_15.1">字符集的依赖关系</a>
<li><a href="#toc_15.2">查看字符编码</a>
<li><a href="#toc_15.3">查看表的字符集</a>
<li><a href="#toc_15.4">查看数据库字符集</a>
<li><a href="#toc_15.5">修改默认字符集</a>
</ul>
<li><a href="#toc_16">Liunx下修改MySQL字符集</a>
<ul>
<li><a href="#toc_16.1">修改mysql服务器的默认字符集</a>
<li><a href="#toc_16.2">修改数据库的字符集</a>
<li><a href="#toc_16.3">字符集校对规则</a>
<li><a href="#toc_16.4">学习</a>
<li><a href="#toc_16.5">字符集的概念(库)</a>
<li><a href="#toc_16.6">mysql perl 程序编写</a>
<li><a href="#toc_16.7">fetchrow_array</a>
</ul>
<li><a href="#toc_17">备份数据库</a>
<ul>
<li><a href="#toc_17.1">视图</a>
</ul>
</ul>
</div>
<p>
<a href="CIMOM_DATABASE.html">CIMOM_DATABASE</a><br>
<a href="优化数据库.html">优化数据库</a><br>
<a href="perl DBI.html">perl DBI</a><br>
<a href="数据库经验.html">数据库经验</a><br>
<a href="MySQL.html">MySQL</a><br>
<a href="SQL.html">SQL</a><br>
<a href="ORACLE.html">ORACLE</a><br>
<a href="数据库操作不了检查.html">数据库操作不了检查</a><br>
<a href="存储过程.html">存储过程</a><br>
<a href="索引.html">索引</a><br>
</p>

<h1 id="toc_1">飞伟 </h1>
<p>
安全性-》登陆名-》新建登陆名
EMS4BQ(先把数据库下面的用户名删掉)
密码：EMSPW4SZBQPCB.COM
服务器角色全部勾上，不然可能出现看不见表
用户映射里面勾选DATABASE4BQ		EMS4BQ		dbo
Conn_Create
Get_StrConnect
</p>


<h1 id="toc_2">C#连接数据库</h1>
<p>
定义连接字符串
1，新建连接
SqlConnection conn
</p>

<p>
2，执行命令
打开连接
</p>


<p>
sqlCommand
sqlDataReader
</p>

<p>
StringWriter和
</p>

<h1 id="toc_3">varchar和nvarchar</h1>
<p>
varchar：非Unicode的字符数据
</p>

<p>
nvarchar：Unicode字符集数据，字节的存储大小是所输入字符个数的两倍。
</p>

<h2 id="toc_3.1">占的字节数不同</h2>
<p>
varchar 如果是英文,则占一个字符
中文,占两字符
</p>

<p>
nvarchar 英文,中文,都占两个字符
</p>

<p>
如字段值只是英文可选择varchar，而字段值存在较多的双字节（中文、韩文等）字符时用nvarchar
</p>

<h1 id="toc_4">编辑前200行里面</h1>
<p>
有对数据的结果进行插入和新建表功能
</p>

<h1 id="toc_5">顺序</h1>
<p>
from... …  where... group by... 
having.... select ... order by...
</p>

<p>
连接池：当close或者dispose的时候，不释放连接池里面的内容，当100ms之内有同样的连接字符串出现的时候直接使用连接池里面的字符串，不用再重新连接。当调用close的时候，就放在连接池里面。用dispose会自动调用close
如果在连接字符串中加上pooling=false，则不管有没有调用close都没有用到连接池，也就是连接池已经被禁用掉。
</p>

<p>
所以，进可能早点关，尽可能开。也就是持有连接对象的时间越短越好。
</p>

<p>
在我们创建一个连接的实例，并调用Open()方法时，连接池管理程序会在连接池中找到一个可用的连接；当调用Close()方法时，连接池管理程序又将连接返回到连接池中，以供下一次调用Open()方法时使用。
</p>

<p>
如果需要重复运行相同的查询语句，不要让大部分的时间都花费在语句的语法语义检查上。为了避免，一般对查询分两步执行。第一步先预备查询语句prepare。第二步真正查询。
$dbh-&gt;prepare('SELECT * FROM table WHERE id = ?');
？是一个占位符，碰到占位符语句，数据库会自动缓存，作为执行计划缓存起来。后续需要查询的时候很快很方便。
\(dbh-&gt;execute(\)id);
</p>


<h2 id="toc_5.1">预备多条查询语句应对不同情况</h2>
<p>
DBI无法处理自动变长参数
</p>

<p>
同一个数据库的关系都是用关键字连接在一起的。外键
</p>

<h1 id="toc_6">表联接</h1>
<p>
不管什么连接，表的一行和另外表所有行进行条件比对。然后表的另外一行和另外表的所有行进行比对。
</p>

<p>
left join 
左边的行数大于或等于不连接的行数
右边只显示满足条件的，不满足条件的为NULL
输出左边，右边的满足条件的连接到右边，不满足条件的用null表示
</p>

<p>
right join
右边的行数大于或等于不连接的行数
左边只显示满足条件的，不满足条件的为NULL
</p>

<p>
inner join
必须左右相等才连接
</p>

<p>
看行数的要根据原来行数和符合条件的个数。
</p>

<p>
<code>如果左右表都符合条件连接，则和左右内连接没有关系</code>否则才有关系
</p>

<h1 id="toc_7">union和unionall</h1>
<p>
如果我们需要将两个select语句的结果作为一个整体显示出来，我们就需要用到union或者union all关键字。union(或称为联合)的作用是将多个结果合并在一起显示出来。 
</p>

<p>
union:对两个结果集进行并集操作，不包括重复行(过滤掉重复行)，同时进行默认规则排序。
Union All: 对两个结果集进行并集操作，包括重复行，不进行排序。
Interset：对两个结果集进行交集操作，不包括重复行，同时进行默认规则排序。
Minus: 对两个结果进行差操作，不包括重复行，同时进行默认规则排序。
</p>


<h1 id="toc_8">库由表组成</h1>
<p>
字段(列)   表(系统表，数据字典)   库   MySQL服务器
</p>
<h2 id="toc_8.1">windows 启动mysql</h2>
<p>
其中第二种方法对我这无效，以后再搞清楚！
</p>

<p>
一、MYSQL服务
</p>

<p>
我的电脑——（右键）管理——服务与应用程序——服务——MYSQL——开启（停止、重启动）
</p>

<p>
二、命令行方式
</p>

<p>
　Windows
</p>

<p>
　　1.点击“开始”-&gt;“运行”(快捷键Win+R)。
</p>

<p>
　　2.启动：输入 net stop mysql
</p>

<p>
　　3.停止：输入 net start mysql
</p>

<p>
　　提示* Redhat Linux 也支持service command，启动：# service mysqld start 停止：# service mysqld stop 重启：# service mysqld restart
</p>

<p>
　　* Windows下不能直接重启(restart)，只能先停止，再启动。
</p>

<p>
三、Too many connections
</p>

<p>
2008-04-30┆379,578 Views┆56,071
</p>

<p>
错误编号：1040
问题分析：
</p>

<p>
连接数超过了 MySQL 设置的值，与 max_connections 和 wait_timeout  都有关系。wait_timeout 的值越大，连接的空闲等待就越长，这样就会造成当前连接数越大。
</p>

<p>
解决方法：
</p>

<p>
1、虚拟主机用户请联系空间商优化 MySQL 服务器的配置；
</p>

<p>
2、独立主机用户请联系服务器管理员优化 MySQL 服务器的配置，可参考：
</p>

<p>
修改 MySQL 配置文件（Windows下为 my.ini， Linux下为 my.cnf ）中的参数：
</p>

<p>
CODE: [COPY] 
max_connections= 1000 
wait_timeout = 5 
</p>

<p>
如果没有可以自行添加，修改后重启 MySQL ，如果经常性的报此错误，请您按照服务器环境搭建教程检查下你的服务器
</p>

<h2 id="toc_8.2">linux 如何启动/停止/重启MySQL</h2>

<p>
　　一、启动方式
</p>

<p>
　　1、使用 service 启动：service mysqld start
</p>

<p>
　　2、使用 mysqld 脚本启动：/etc/inint.d/mysqld start
</p>

<p>
　　3、使用 safe_mysqld 启动：safe_mysqld&amp;
</p>

<p>
　　二、停止
</p>

<p>
　　1、使用 service 启动：service mysqld stop
</p>

<p>
　　2、使用 mysqld 脚本启动：/etc/inint.d/mysqld stop
</p>

<p>
　　3、mysqladmin shutdown
</p>

<p>
　　三、重启
</p>

<p>
　　1、使用 service 启动：service mysqld restart
</p>

<p>
　　2、使用 mysqld 脚本启动：/etc/inint.d/mysqld restart
</p>

<p>
　　提问 编辑摘要
</p>

<p>
　　如何启动/停止/重启MySQL
</p>

<p>
　　一、启动方式
</p>

<p>
　　1、使用 service 启动：service mysqld start
</p>

<p>
　　2、使用 mysqld 脚本启动：/etc/inint.d/mysqld start
</p>

<p>
　　3、使用 safe_mysqld 启动：safe_mysqld&amp;
</p>

<p>
　　二、停止
</p>

<p>
　　1、使用 service 启动：service mysqld stop
</p>

<p>
　　2、使用 mysqld 脚本启动：/etc/inint.d/mysqld stop
</p>

<p>
　　3、mysqladmin shutdown
</p>

<p>
　　三、重启
</p>

<p>
　　1、使用 service 启动：service mysqld restart
</p>

<p>
　　2、使用 mysqld 脚本启动：/etc/inint.d/mysqld restart
</p>

<p>
　　刚开始学mysql时都是用redhat自带的。启动是什么 /rc.d/init.d/ start
</p>

<p>
　　这很简单，但是后来越学越多，系统自带的mysql，有的是版本太低，有的是与
</p>

<p>
　　自己想要装的web服务需要的低版本的mysql
</p>

<p>
　　后来自己学着以tar的方式安装mysql，我的mysql装在/usr/local/mysql目录下启
</p>

<p>
　　动碰到过很多问题。最常见的是：
</p>

<p>
　　ERROR 2002: Can't connect to local MySQL server through socket
</p>

<p>
　　'/tmp/mysql.sock' (111)
</p>

<p>
　　解决办法：
</p>

<p>
　　[root@test mysql]# /usr/local/mysql/bin/mysqladmin -u root /
</p>

<p>
　　&gt; -S /var/lib/mysql/mysql.sock password 'your.passwd'
</p>

<p>
　　或者做个连接
</p>

<p>
　　ln -s /var/lib/mysql/mysql.sock /tmp
</p>

<p>
　　其实提示找不到 /tmp/mysql.sock有时也并不是/tmp目录下没这个文件，是启动
</p>

<p>
　　命令不对，我碰到过
</p>

<p>
　　常见的几种启动方式，自己也不是记得很清楚，如果你确定tmp下有mysql.sock这
</p>

<p>
　　个文件不妨试试另外的几个命令
</p>

<p>
　　/usr/local/mysql/bin/mysql -u root -p
</p>

<p>
　　/usr/local/mysql/bin/mysqld --user=mysql&amp;
</p>

<p>
　　/usr/local/mysql/bin/mysqld --user=root&amp;
</p>

<p>
　　/usr/local/mysql/bin/mysqld_safe --user=root&amp;
</p>

<p>
　　/usr/local/mysql/bin/mysqld_safe --user=mysql&amp;
</p>

<p>
　　/usr/local/mysql/bin/safe_mysqld--uer=root&amp;(注意safe_mysqld与mysqld_safe是不同的，&amp;表示mysql在后台运行)我的就会报错了
</p>

<p>
　　STOPPING server from pid file
</p>

<p>
　　/usr/local/mysql/data/localhost.localdomain.pid
</p>

<p>
　　060304 11:46:21 mysqld ended
</p>

<p>
　　这是权限问题，我的mysql目录属于root用户，也属于root群组，改用mysqld_safe启动就没问题了，
</p>

<p>
　　大家只要注意这几个mysql,safe_mysqld,mysqld_safe,mysqld,mysqladmin.多试
</p>

<p>
　　几次
</p>

<p>
　　其实有时mysql已经正常启动了，查看mysql是否启动命令
</p>

<p>
　　ps -aux | grep mysqld
</p>

<p>
　　会看到如下类似内容
</p>

<p>
　　mysql 6394 0.0 1.5 10528 992 pts/3 S 16:16 0:00
</p>

<p>
　　/usr/local/mysql/
</p>

<p>
　　mysql 6395 0.0 1.5 10528 992 pts/3 S 16:16 0:00
</p>

<p>
　　/usr/local/mysql/
</p>

<p>
　　mysql 6396 0.0 1.5 10528 992 pts/3 S 16:16 0:00
</p>

<p>
　　/usr/local/mysql/
</p>

<p>
　　root 6422 0.0 1.1 2408 732 pts/3 S 16:20 0:00 grep
</p>

<p>
　　mysql
</p>

<p>
　　查看mysql是否在监听端口命令
</p>

<p>
　　netstat -tl | grep mysql
</p>

<p>
　　会看到如下类似内容
</p>

<p>
　　tcp 0 0 *:mysql <strong>:</strong> LISTEN
</p>

<h4 id="toc_8.2.0.1">如何进入mysql</h4>
<p>
cmd-&gt;进入命令模式，输入mysql -uroot -p
然后输入密码
</p>

<p>
输入过程中如果要取消本次命令可以按esc或后面输入\c
</p>
<h4 id="toc_8.2.0.2">数据库操作</h4>
<p>
显示数据库：show databases;
选择数据库：use database(数据库名称);
创建数据库：create database test;
			create database test character set utf8;
删除数据库：drop database test;
</p>

<h4 id="toc_8.2.0.3">表操作</h4>

<p>
定义：
 主键--唯一标识一条记录，不能有重复的，不允许为空
 外键--表的外键是另一表的主键, 外键可以有重复的, 可以是空值
 索引--该字段没有重复值，但可以有一个空值
</p>
 
<p>
作用：
 主键--用来保证数据完整性
 外键--用来和其他表建立联系用的
 索引--是提高查询排序的速度
</p>
 
<p>
主键：表中唯一的识别
外键：外面表的主键，通过该键查找外面表(在外面来看是唯一的)
</p>

<p>
如学生表, 课程表，成绩表。成绩表中极有学生表的主键(外键)，也有课程表的主键(外键)，通过外键查找针对的某个学生对应的某个课程的成绩
</p>

<h2 id="toc_8.3">显示表：</h2>
<p>
show tables;
</p>

<h2 id="toc_8.4">创建表</h2>
<p>
建表；create table students
	(
		id int unsigned not null auto_increment primary key,
		name char(8) not null,
		sex char(4) not null,
		age tinyint unsigned not null,
		tel char(13) null default "-"
	) default character set utf8;	
</p>
	
<p>
create table stuents
	(id int(10) primary key auto_increment, 
	 sname char(30) not null, 
	 sex tinyint(1) default 0, 
	 qq varchar(255)) default character set utf8 engine  myisam;
</p>
	
<p>
#创建表，字段name的格式为utf8，字段name1的格式为gbk
create table students(
		name varchar(30) character set utf8,
</p>
<blockquote>
name1 varchar(30) character set gbk);
</blockquote>
	   	

<p>
表的内容，某个字段的内容以ID号的形式显示。当要修改该部分内容的时候，直接修改该id号所对应的内容即可，而不用修改该表的所有该字段的内容。这样节省了时间和操作。
</p>

<p>
视图的一个重要作用是：把这些表关系连接起来，这样操作数据库的时候直接针对该视图即可。而不用每次查询时都要处理复杂的表关系。
</p>

<p>
视图可以一目了然的看出表与表之间的关系
</p>



<h2 id="toc_8.5">删除表</h2>
<p>
drop table student;
</p>

<h2 id="toc_8.6">删除表(某记录 行)内容：</h2>
<p>
DELETE FROM HC_ChkLayerList;
DELETE FROM HC_ChkItemList
</p>

<p>
delete from 表 where ~
</p>

<h2 id="toc_8.7">插入表</h2>
<p>
insert into students (name, age) values("张三",24);
连续插入两个数据(用逗号隔开)：
	insert into students (name, age) values ("李四", '22'), ("王五", '22')
	insert into 表 (列1，列2) values (值1，值2)
</p>

<h2 id="toc_8.8">更改表内容</h2>
<p>
update 列表 set 字段 = 改变后的值
update stu set birday="1990/4/23" where id = 1;
update students set age = '23' where id = 1;
</p>

<p>
#追加一个字段
alter table students add qq char(8);
修改表 students 追加一个字段qq char(8)类型
alter table students modify name char(30) character set utf8;
修改表 students 改变name的类型为char(30), 字符编码为utf8;
</p>


<h2 id="toc_8.9">查看表结构</h2>
<p>
desc students
</p>
	
<h2 id="toc_8.10">查询表(输出表内容(字段内容:由一个字段的值获取另一个字段的值))</h2>
<p>
查询的先后顺序
from... where... group by... 
having.... select ... order by...
</p>

<p>
多少个逗号，就有多少个字段被查询显示
select 字段(列)(可以多个，用逗号隔开) from 表 where (条件)
select * from student;
select name, sex from students;
select * from students where name="李四";#先搜寻where name = "李四"，然后输出
select * from students where sname like "李%"; #like就像是=~， %类试*
select * from students limit 2; #取两条
select * from students order by id desc limit 2;
desc下降，asc升序，limit 取2条，界限 order排序
select name, birday from students order by birday asc limit 1;
查找年龄最大的学生
select sname, birday from stu order by birday limit 2,3;
limit 2,3表示从2个开始取，顺序取三个3个
select * from stu where age &gt;= "25";
select concat("姓名", name, "性别:", sex,  "QQ:", qq) as "students信息" from students;#connect cat(连接并cat)
</p>

<p>
select name as "姓名", sex as "性别" from students;
为查询结果的字段取别名(注意不是对数据库里面的字段取别名，而是对查询的结果字段取别名)：select name as 姓名, age as 年龄 from students;结果显示的时候name会用姓名取代。可以省略as也就是，select name 姓名, age 年龄 from students
</p>

<p>
SELECT
tl.ID,
tl.ItemID,
tl.ChkStep,
tl.ItemName,
tl.ItemDesc,
tl.ProgName,
tl.ProgVer,
</p>

<p>
CASE
	WHEN ISNULL(ll.ChkStatus) THEN 'NULL'
	ELSE ll.ChkStatus
END AS ChkStatus,
</p>

<p>
ll.Mark,
</p>

<p>
CASE
	WHEN ISNULL(ll.id) THEN 'NULL'
	ELSE ll.id
END as llid,
</p>

<p>
ll.ChkUser
</p>

<p>
FROM
HC_Chk_ItemList AS tl
LEFT JOIN (select * FROM HC_Chk_LayerList WHERE JobName = '\(job'  AND LayerName = '\)layer') AS ll ON tl.ID = ll.ChkItemID
</p>

<p>
WHERE
tl.LayerType = '$layType' AND
tl.ProgStatus = 1
</p>

<p>
ORDER BY
tl.ItemID ASC
</p>

<p>
select段：获取需要的字段
(1,t1某个字段；2，l1某个字段；)
CASE 一个字段；语句的开始 when两种情况ELSE
FROM段：所组成的表
1，HC_Chk_ItemList; 2, 从HC_Chk_LayerList查询出来的结果
WHERE段：某字段必须符合的条件
ORDER段：根据什么排序
</p>

<p>
select 
</p>
<ul>
<li>


</ul>
<p>
from 
</p>

<p>
(select * from MI where order_type = "新单") as ta 
LEFT JOIN (select * from HC_job_erp_info where JOB_NAME like "%62%") as tb 
ON tb.rkey = ta.job_rkey  
前面MI的优先查出，然后加入满足条件的HC_job_erp_info，(不满足的为空(不加入))
</p>

<p>
select * from HC_job_erp_info  as ta LEFT JOIN (select * from MI ) as tb ON ta.rkey = tb.job_rkey where ta.JOB_NAME like "%62486%"
</p>

<p>
select sb1, sb2, sb3 from (select s1 as sb1, s2 as sb2, s3*2 as sb3 from t1) as sb where sb1 &gt; 1
</p>

<p>
select id, name, sex, 2015-birth as age, department, address from student where 2015-birth &gt;=18 and 2015-birth &lt;=25;
</p>

<p>
select * from student where department in('计算机系', '英语系');
</p>

<h1 id="toc_9">left join right join inner join</h1>
<p>
left join 
</p>

<h1 id="toc_10">聚合函数</h1>
<p>
聚合函数有：
count()
sum()
avg()
min()
max()
	跳过NULL值
</p>

<h1 id="toc_11">group by 分组，各个</h1>
<p>
<code>注意: group by 以后的选择输出只能是group by里面含有的字段，或者是经过聚合函数处理过的字段, 聚合函数处理的是对分组后的每组的小表进行计算，而不是大表</code>
对某个类进行操作(查询结果为某一个类)。只会对某类查询一行结果。(多少类，结果为多少行)，缺省值为输出各类的第一行。
先归类，然后按照条件输出
SELECT DEPT, sum( SALARY ) AS total
FROM STAFF
GROUP BY DEPT
</p>

<p>
可以对多个字段进行分组，表示既是相同的DEPT，也是相同的EDLEVEL为一组，比如工程部的技术员为一组，样品部的工程师为一组一样
SELECT DEPT, EDLEVEL, MIN( SALARY ) AS MAXIMUM
FROM staff
WHERE date &gt; '2009-01-01'
GROUP BY DEPT, EDLEVEL
ORDER BY DEPT, EDLEVEL
</p>

<h2 id="toc_11.1">having</h2>
<p>
having和where的功能是一样的，只是位置having一般和grop by一起用，对group by后的表进行条件过滤
having by可以对分组加上条件，也就是符合组符合条件的获取出来，其它不获取
求大于两个人的部门
SELECT *
FROM staff
GROUP BY DEPT
HAVING COUNT( * ) &gt; 2
ORDER BY DEPT
</p>

<p>
求平均工资大于3000的部门
SELECT DEPT, MAX( SALARY ) AS MAXIMUM, MIN( SALARY ) AS MINIMUM
FROM staff
GROUP BY DEPT
HAVING AVG( SALARY ) &gt;3000
ORDER BY DEPT
</p>


<h1 id="toc_12">order by</h1>


<h1 id="toc_13">asc desc</h1>
<p>
默认为asc升序，desc为降序
</p>

<h1 id="toc_14">limit</h1>
<p>
取个数，limit 3，表示取3个，limit 2，3，表示从第二个开始取，取三个
</p>

<h1 id="toc_15">求取某一部门的工资最低值</h1>
<p>
SELECT DEPT, MIN(SALARY)
FROM STAFF
GROUP BY DEPT
</p>

<p>
先FROM STAFF，然后Group by Dept，然后，选取DEPT字段和SALARY字段，要求SALARY最小值。
group by DEPT 对DEPT进行分类，结果只取一个，默认为查询到的第一个。
</p>
<h4 id="toc_15.0.0.1">执行语句</h4>
<p>
\(sth = \)dbh-&gt;parepare();
$sth-&gt;execute();
$sth-&gt;fetchrow_array();
</p>

<h4 id="toc_15.0.0.2">字符集的概念(库)</h4>
<p>
gbk :21000多个汉字(简体+繁体) 大五码，2个字节
</p>

<p>
gb2312：6700个汉字简体新华字典(2个字节来存储)
</p>

<p>
utf8：1-3个字符集(可变长度存储)
</p>

<p>
unicode(国际标准化组织涵盖所有语种，所有符号的编码方案)
</p>

<p>
big5 繁体字典
</p>

<p>
character_set_server 被设定为这个mysql服务器默认字符集, 可以在mysql下default-character-set=latin1设置默认字符集
</p>

<h2 id="toc_15.1">字符集的依赖关系</h2>
<p>
1，如果创建一个新的数据库时，没有明确指定字符集，那么使用mysql服务默认字符集character_set_server
2，当选定了一个数据库的时character_set_database为默认的字符集
3，如果创建一个新的表，没有明确指定字符集，那么使用数据库默认字符集character_set_database
4，当在表内设置一栏时，除非明确指定，否则此栏缺省的字符集就是表默认的字符集；
</p>

<p>
插入一个字段最好指定字符集
</p>

<p>
字段指定了字符集没有指定校对规则。会采用默认的。可以使用
</p>

<p>
如果指定了校对规则，没有指定字符集，会使用校对规则的字符集utf8-bin utf8
</p>

<p>
如果字段没有指定校对规则，也没有指定字符集，依据表的字符集
</p>

<p>
如果表也没指定字符集，依据库的字符集
</p>

<p>
库没有指定 mysql的默认字符集与校对规则
</p>

<p>
在建表的时候要一定指定字符集端，不要依赖于库
</p>

<h2 id="toc_15.2">查看字符编码</h2>
<p>
show variables like 'char%'
show variable like "%character%"
</p>

<h2 id="toc_15.3">查看表的字符集</h2>
<p>
show create table students;
</p>

<h2 id="toc_15.4">查看数据库字符集</h2>
<p>
navicat选中数据库单击数据库属性
</p>

<h2 id="toc_15.5">修改默认字符集</h2>
<p>
(1) 最简单的修改方法，就是修改mysql的my.ini文件中的字符集键值
	default-character-set = utf8 修改完后，重启mysql的服务，service mysql restart
(2) 用mysql命令SET character_set_client = utf8 ; 只能本次有效，下次重启后还是恢复到my.ini下的default-character-set的字符集，故要彻底改变，需改变my.ini的文件
</p>

<h1 id="toc_16">Liunx下修改MySQL字符集</h1>
<h2 id="toc_16.1">修改mysql服务器的默认字符集</h2>
<p>
1.查找MySQL的cnf文件的位置
	find / -iname '*.cnf' -print
	/usr/share/mysql/my-innodb-heavy-4G.cnf
	/usr/share/mysql/my-large.cnf
	/usr/share/mysql/my-small.cnf
	/usr/share/mysql/my-medium.cnf
	/usr/share/mysql/my-huge.cnf
	/usr/share/texmf/web2c/texmf.cnf
	/usr/share/texmf/web2c/mktex.cnf
	/usr/share/texmf/web2c/fmtutil.cnf
	/usr/share/texmf/tex/xmltex/xmltexfmtutil.cnf
	/usr/share/texmf/tex/jadetex/jadefmtutil.cnf
	/usr/share/doc/MySQL-server-community-5.1.22/my-innodb-heavy-4G.cnf
	/usr/share/doc/MySQL-server-community-5.1.22/my-large.cnf
	/usr/share/doc/MySQL-server-community-5.1.22/my-small.cnf
	/usr/share/doc/MySQL-server-community-5.1.22/my-medium.cnf
	/usr/share/doc/MySQL-server-community-5.1.22/my-huge.cnf
</p>

<p>
2. 拷贝 small.cnf、my-medium.cnf、my-huge.cnf、my-innodb-heavy-4G.cnf其中的一个到/etc下，命名为my.cnf
	cp /usr/share/mysql/my-medium.cnf /etc/my.cnf
</p>

<p>
3. 修改my.cnf
	vi /etc/my.cnf
</p>

<p>
	在[client]下添加
	default-character-set=utf8
</p>

<p>
	在[mysqld]下添加
	default-character-set=utf8
</p>

<p>
4.重新启动MySQL
</p>


<p>
	[root@bogon ~]# /etc/rc.d/init.d/mysql restart
	Shutting down MySQL                                        [ 确定 ]
	Starting MySQL.                                            [ 确定 ]
	[root@bogon ~]# mysql -u root -p
	Enter password:
	Welcome to the MySQL monitor. Commands end with ; or \g.
	Your MySQL connection id is 1
	Server version: 5.1.22-rc-community-log MySQL Community Edition (GPL)
</p>

<p>
	Type 'help;' or '\h' for help. Type '\c' to clear the buffer.
</p>
	
<h2 id="toc_16.2">修改数据库的字符集</h2>
<p>
alter database yourDataBase default character set utf8 collate utf8_general_ci;
直接修改配置文件
D:\install\mysql\data\test\db.opt
重起MySQL:
		[root@bogon ~]# /etc/rc.d/init.d/mysql restart
</p>
		
<h2 id="toc_16.3">字符集校对规则</h2>
<p>
一个区分大小写，一个不区分大小写
create table students(name varchar(30) character set utf8 collate utf8_bin, name2 varchar(30) character set utf8 collate utf8_general_ci) default character set utf8;
</p>

<p>
在表里面插入字段
insert into students (name, name2) values("linwei", "linwei");
然后匹配打印 select * from students where name like "Lin%";name字段的校对规则区分大小写，所以没有匹配找到的字段。
但，select * from students where name2 like "Lin%"，可以匹配到linwei，所以可以打印出来
</p>

<h2 id="toc_16.4">学习</h2>
<p>
6，gtant all on test.* to "lw"@"localhost" identified by "lw";
</p>

<p>
插入内容：
</p>

<p>
mysqldump -uroot -p student&gt;d:aa.sql
</p>


<p>
source 执行外部的sql文件
</p>

<p>
select if (sex, "男生", "女生") as stu sex, sname, sex from stu;
</p>

<p>
select distinct year(birday) as "aa" from stu;
</p>

<p>
去除重复记录
</p>

<p>
关于子查询和多表操作
二进制
</p>

<p>
binary, varbinary,blob
</p>

<p>
声音、图像等二进制数据字符集无关的
</p>

<p>
header("content-type:image/jpeg")
</p>

<p>
与
</p>

<p>
非二进制
</p>

<p>
char,varchar,text
</p>

<p>
想把图像，声音保存必须用二进制去保存
</p>


<h2 id="toc_16.5">字符集的概念(库)</h2>

<p>
引用2楼的答案 执行插入语句前,先执行set names gbk; 就能解决楼主提出的Incorrect string value:"\ \ \ \ \"for column'trurname' at row 1 问题解决
</p>

<p>
select length(name), length(name2) from demo;
</p>

<p>
select char_length(name), char_length(name) from demo;多少个字符。而不是多少个字节
</p>

<p>
delete from demo2 where name='B';
</p>

<p>
create table demo3(name binary(3), name2 varchar(3)) default character set utf8;
</p>

<p>
binary表示能存3个字节，varchar表示能存3个字符
</p>



<p>
set names gbk(一般不用这种方式设置字符集)
</p>

<p>
addslashes(一般不用这种方式处理)
</p>

<p>
show variables like "%collation%"
</p>

<p>
set_client | gbk  终端的字符集,客户端来源数据使用的字符集
</p>

<p>
set_connection |gbk 连接字符集，要和字段的字符集一样，不然会乱码
</p>

<p>
set_rusults | gbk 发送命令查询后返回回来的字符集，一般要和php的字符集(就是发出去的字符集)一样。
</p>

<p>
前面三个如果设置不当可能存在注入的危险
</p>

<p>
client-&gt;connection-&gt;server;
server-&gt;connection-&gt;result-&gt;client;
要保证两点：1，必须保证程序和访问的数据库服务器编码要一致。
			2，保证中途的连接和结果编码一致
			3，保证client和客户端的编码要一致
</p>

<p>
区分终端编码和client编码，终端编码是固定的，不变的。要设置client编码和终端编码一样才能匹配。
下面情况可能出现字符乱码情况，终端本来是gtk字符集的，而偏偏设置的时候设置成utf8的，会乱码
character_set_database |latin1 当前选中中的数据库字符集
</p>

<p>
set_filesystem 文件系统的字符集
</p>

<p>
这两个的字符集一般不改变
</p>

<p>
character_set_server |latin1 默认操作字符集
</p>

<p>
set_system | 系统元数据字符集
</p>

<p>
set_dir  | 字符设置目录
</p>


<p>
create database y default character set utf8;
</p>

<p>
 create database i default character set utf8;
</p>

<p>
 use i;
</p>

<p>
 create table user(name char(30) character set gbk) default character set utf8;
</p>

<p>
gbk是指定字段的数据字符集
</p>

<p>
 show create table user\G
</p>

<p>
 select * from user;元数据的字符集由set_system决定
</p>

<p>
 select 输出
</p>

<p>
 update更新
</p>

<p>
 delete删除
</p>

<p>
 insert
</p>

<p>
 desc
</p>

<p>
 use
</p>

<p>
 select name from user where name = '李四'
</p>

<p>
 发送出去的'李四'字符集和库里面的'李四'字符集，必须一样才能比对。
</p>

<p>
 转是先php的字符集转换成连接字符集(一般和客户端字符集是一样的)，然后转换成字段字符集
</p>

<p>
 insert into user (name) values("李四"), ("王五");
</p>

<p>
 读取的数据就是客户端的数据
</p>


<p>
set names utf8;会把set_client | gbk  客户端的字符集
</p>

<p>
set_connection |gbk 连接字符集
</p>

<p>
set_rusults | gbk 发送命令查询后返回回来的字符集，一般要和p
</p>

<p>
全部转换成utf8；
</p>

<p>
发送要发送正确，比如终端是gbk字符集的，然后你偏偏说client是utf8的，那么发送出去的就是utf8的，明显不对。这样必然错误。所以终端要和client字符集一样。
</p>

<p>
然后到达连接字符集，转换成连接字符集，然后连接字符集和字段比较，如果不一样，乱码。
</p>

<p>
然后返回到达返回字符集。返回字符集要和终端字符集一样，不然乱码。
</p>

<p>
所以终端，client客户，返回字符集必须一样。
</p>

<p>
create table user(id int(10) primary key auto_increment, uname char(30), password char(32), tel char(12), qq char(12)) default character set gbk;
</p>

<p>
insert into user (uname, password, tel, qq) values('admin', md5(123), 11111, 333333);
</p>

<p>
数据库的批量操作
</p>

<p>
perl访问数据库utf8或iso-8859-1
</p>

<h2 id="toc_16.6">mysql perl 程序编写</h2>
<p>
use DBI;
#使用模块里面的DBI::connect函数，然后bless引用，可以直接使用该模块里面的函数。
my \(dbh = DBI-&gt;connect(\)dsn, \(sqlUser, \)sqlPwd, $attributes);
#字符串加上单引号
\(dbh-&gt;quote("\)name");
</p>

<p>
#由selectall_arrayref获取矩阵引用。指向每行的引用,每行的引用指向每列。
my matrixRef = $dbh-&gt;selectall_arrayref();
</p>

<p>
#产生mySQL命令
my $sqlCmd = "SELECT * FROM students";
</p>

<p>
#准备执行
my \(sth = \)dbh-&gt;prepare($sqlCmd);
</p>

<p>
#执行命令
$sth-&gt;execute();
</p>

<p>
#获取一行
my @data = $sth-&gt;fetchrow_array();
</p>

<h2 id="toc_16.7">fetchrow_array</h2>
<p>
fetchrow_array对输出(搜寻)的结果一次取出一行
#获取哈希引用，键为字段，值为字段所对应的值，一次只获取一行
my \(rowHashRef = \)sth-&gt;fetchrow_hashref();
</p>

<p>
#获取数组的引用。一次获取一行的所有字段值所组成的数组
my \(rowArrayRef = \)sth-&gt;fetchrow_arrayref();
</p>

<p>
#一次获取所有，放在引用里面
my \(rowArrayAllRef = \)sth-&gt;fetchall_arrayref();
</p>

<h1 id="toc_17">备份数据库</h1>
<p>
在navicat里面右击，然后选择数据传输，可以在数据库和数据库之间传输数据
</p>

<h2 id="toc_17.1">视图</h2>
<p>
1.在使用视图的时候，就是与使用表的语法一样的。
2.创建视图的时候，该视图的名字如果与已经存在表重名的话，那么会报错，不允许创建。视图就是一种特殊的表
</p>

<p>
视图其实是一个表，假表，说假表是因为其没有保存内容，只是引用其他表的内容
</p>

<p>
视图的一个重要作用是：把这些表关系连接起来，这样操作数据库的时候直接针对该视图即可。而不用每次查询时都要处理复杂的表关系。
</p>

<p>
视图可以一目了然的看出表与表之间的关系
</p>

<p>
视图和表的不同
	1，不能在视图上创建触发器。
	2，不能Drop table删除视图
</p>

<button class="back_to_top" style='background-color:red'>返回顶部</button>

<a href="https://weipiaoyun.github.io/note_html/我的主页.html">
<button class="back_to_index" style='background-color:red'>返回首页</button>
</a>

<script src="my.js"></script>
<HR SIZE=5>
<p class="left">
<!-- <div class="text" style=" text-align:center;font-size:15px"></div>-->
© <span id="year">2018</span> 
</p>
</body>
</body>
</html>
